 /* _pli_CAC                                                         */
 /********************************************************************/
 /*           Iron Spring PL/I Runtime Library Version 0.5           */
 /*              Distributed under the Gnu LGPL License              */
 /*                                                                  */
 /*      Module:        _pli_CAC (PL/I runtime)                      */
 /*      Version:       1.0                                          */
 /*      Date:          Apr, 2001                                    */
 /*      Author:        Peter Flass                                  */
 /*                                                                  */
 /*      Entry Points:  _pli_CAC                                     */
 /*                                                                  */
 /*      Function:      Convert coded arithmetic [FIXED DEC(n,m)]    */
 /*                     to character string.                         */
 /*                                                                  */
 /*                     "The constant is inserted into an            */
 /*                      intermediate string whose length is         */
 /*                      derived from the attributes of the source." */
 /*                     "The [fixed decimal] constant is right-      */
 /*                      adjusted in a field of width p1+3".         */
 /*                                              -SC26-3114-01, p.90 */
 /*                                                                  */
 /*      Dependencies:                                               */
 /*                     Intel BCD format.                            */
 /*                                                                  */
 /*      Calling sequence:                                           */
 /*                                                                  */
 /*      Input:                                                      */
 /*                        +--------------------------------------+  */
 /*                     +8 | -> Output area (26 or 52 bytes)      |  */
 /*                        +--------------------------------------+  */
 /*                     +4 | -> Descriptor for FIXED DEC input    |  */
 /*                        +--------------------------------------+  */
 /*                     +0 | -> FIXED DEC input (10 or 20 bytes)  |  */
 /*        Parameters->    +--------------------------------------+  */
 /*                                                                  */
 /*      Output:        Converted character value as CHAR(24) VAR.   */
 /*                     [CHAR(48) if FIXED DEC data is complex]      */
 /*                                                                  */
 /*                     Conversion is described in SC26-3114-01,     */
 /*                     pp.89-91.  The PL/I standard has a useful    */
 /*                     and interesting description in terms of      */
 /*                     PICTURE editing.                             */
 /*                                                                  */
 /*      Called from:   Compiled code.                               */
 /*                                                                  */
 /*      Errors:        SIZE, ERROR.                                 */
 /*                                                                  */
 /*      To Do:                                                      */
 /*                   . Scaling factor                               */
 /*                     (check printing of scaled numbers)           */
 /*                                                                  */
 /*      Modifications:                                              */
 /*          2024-08-29: Print '0' for '-0'                     1.3.2*/
 /*          2024-08-27: (600)Sign not printing for 1-digit num 1.3.2*/
 /*          2022-06-28: (504)Complex data formats incorrectly  1.0.0*/
 /*          2009-07-23: 'convert' - added scale processing.     0.8c*/
 /*          2009-02-11: If SIZE is (or would be) raised, print  0.7b*/
 /*                      leading zero in place of sign character 0.7b*/
 /*                                                                  */
 /********************************************************************/

 (NOFIXEDOVERFLOW):
 pli_CAC: proc(pDec,pDesc,pRet)
                             external( '_pli_CAC' )
                             options( LINKAGE(SYSTEM) );

 dcl     pDec                ptr;                     /* -> Input    */
 dcl     pDesc               ptr;                     /* -> Descript.*/
 dcl     pRet                ptr;                     /* -> Output   */

 dcl     result              char(50)  varying   based( pRet );

 dcl    (n,o)                fixed bin(31);
 dcl    (prec,scale)         fixed bin(31);
 dcl     bComplex            bit(1);
 dcl     tmp             (48)char(1);
 dcl     bSize               bit(1)                   init( '0'b );
 dcl     Sign                char(1)                  init( ' ' );
 
 dcl     FD18                fixed dec(18)   based;           /*0.9.9*/
 dcl     STR                 char(48)        based;           /*1.0.0*/
 dcl     PFX                 fixed bin(15)   based;           /*1.0.0*/

 /* Digit positions for digits 0:17 within BCD number                */
 dcl     d             (0:17)fixed bin(7)   static    init(
          1, 0, 3, 2, 5, 4, 7, 6, 9, 8,11,10,13,12,15,14,17,16 );

 /* Decimal digits 0:9                                               */
 dcl     digit          (0:9)char(1)        static    init(
          '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' );

 %include CONDMASK;

 dcl     GetFlags            entry
                             external( '_pli_GetFlags' )
                             returns( bit(16) )
                             options( LINKAGE(SYSTEM) );

 dcl    (addr,string,substr) builtin;
 %page;

 /*------------------------------------------------------------------*/
 /*                                                                  */
 /*------------------------------------------------------------------*/
 string(cond_mask) = GetFlags();       /* Get enabled conditions     */
 prec  = pDesc->XD_prec;
 scale = pDesc->XD_scale;
 bComplex = (pDesc->XD_cplx&'80'bx)ª='00'bx;
 /*---------------------------------------------*/
 /* Size of result                              */
 /*---------------------------------------------*/
 /* The length of the intermediate string is:                        */
 /*     p1>=q1>=0:     p1+3   (real)                                 */
 /*                    2*p1+7 (imag)                                 */
 /*     p1<q1 or q1<0: p1+abs(q1)+3    (real)                        */
 /*                    2*(p1+abs(q1)+7 (imag)                        */
 if prec>=scale & scale>=0
 then n=prec+3;                        /* Case: p1>=q1>=0            */
 else n=prec+abs(scale)+3;             /* Case: p1<q1 | q1<0         */
 if bComplex then n=n*2;                                      /*1.0.0*/

 o = 0;                                /* Output pointer             */

 /*---------------------------------------------*/
 /* Convert real part                           */
 /*---------------------------------------------*/
 if pDec->BCD_sign & pDec->FD18^=0     /* Get sign '-' or ' '   1.3.2*/
 then Sign = '-';                      /* Force sign                 */
 call convert;                                                /*1.0.0*/

 /*---------------------------------------------*/
 /* Convert imaginary part                      */
 /*---------------------------------------------*/
 if bComplex then do;
   pDec = addr(pDec->BCD_end);         /* ->Imaginary part           */
   if pDec->BCD_sign & pDec->FD18^=0   /* Get sign '-' or ' '   1.3.2*/
   then Sign = '-';                    /* Force sign for imaginary   */
   else Sign = '+';
   call convert;                                              /*1.0.0*/
   o=o+1;
   tmp(o) = 'I';
   end; /* bComplex */
  
 /*---------------------------------------------*/
 /* Move result string                          */
 /*---------------------------------------------*/
 addr(Result)->PFX = n;
 call plifill( addr(result)+stg(PFX), ' ', n );/* Fill result   1.0.0*/
 if bComplex                                                  /*1.0.0*/
 then substr(Result,(n-o)/2,o) = substr(addr(tmp)->STR,1,o);  /*1.0.0*/
 else substr(Result,n-o+1,o)   = substr(addr(tmp)->STR,1,o);  /*1.0.0*/
 /*Result = substr(string(tmp),1,o);   /* Save converted result 0.9.9*/

 /*---------------------------------------------*/
 /* Handle any errors                           */
 /*---------------------------------------------*/
 if bSize then signal SIZE;

 return;

 /*---------------------------------------------*/
 /* Convert Real or Imaginary Part of Source    */
 /*---------------------------------------------*/
 convert: proc;                                               /*1.0.0*/
 dcl    (i,j)                fixed bin(31);
 dcl     bSig                bit(1);
 dcl     c                   char(1);
 /* IBM PL/I left-justifies the imaginary part of a complex number   */
 /* and blank-fills on the right.                                    */
 dcl     xscale              fixed dec(18);                /*20090723*/

 bSig = '0'b;                                                 /*1.0.0*/
 /* --- stuff deleted for 1.0.0 --- */
 do i = 17 to 0 by -1;                 /* Look at all decimal digits */

   j = pDec->BCD_dig( d(i) );          /* Get next digit             */
   if j>9 then do;                     /* Invalid digit              */
     /* Per the PL/I standard, this can't be CONVERSION,             */
     /* it must be ERROR.                                            */
     signal ERROR;                     /* This is 'ERROR'            */
     /* Control does not return       */
     end;
 
   /*---------------------------------*/
   /* Do not convert digits outside   */
   /* of the declared precision.      */
   /* If they aren't zero, raise SIZE.*/
   /*---------------------------------*/
   if i>=prec then do;                 /* Check this digit           */
     if jª=0 & M_size then bSize='1'b; /* Set 'SIZE' flag            */
     if jª=0 then Sign='0';            /* If SIZE                0.7b*/
     end; /* ignoring */
   
   else do;                            /* Process this digit         */
     c = digit(j);                     /* Get a digit        20061003*/
 
     if ªbSig then do;                 /* Sig. not started   20061003*/
       if cª='0' | i=scale |           /* Sign at this point 20090723*/
          i=0                                                 /*(600)*/
 /*       (i=0 & scale<0)                                     /*(600)*/
       then do;                                            /*20090723*/
         o=o+1;
         tmp(o) = Sign;                /* Insert sign or blank       */
         bSig='1'b;                    /* Sig. started now   20061003*/
         end;   
       if c='0' & i^=scale then c=' ';                     /*20220630*/
       end; /* ªbSig */                                    /*20061003*/
     if c^=' ' then do;                                       /*1.0.0*/
       o=o+1;                          /* ->Next output pos          */
       tmp(o) = c;                     /* Store this digit           */
       end;                                                   /*1.0.0*/

     if i=scale & scaleª=0 then do;    /* Need decimal point?20071129*/
       o = o+1;                                            /*20060922*/
       tmp(o) = '.';                   /* Store decimal point        */
       bSig = '1'b;                                           /*1.0.0*/
       end; /* i=scale */                                  /*20061003*/
/*     if i=1 then bSig='1'b; /* Start significance if not 1.3.2 */

     end; /* i<prec */

   end; /* do i */

   /* IBM: "if p1<q1 or q1<0 a scaling factor appends to the right   */
   /*      the constant; the constant is an optionally signed        */
   /*      integer.  The scaling factor appears even if the value    */
   /*      of the item is zero.  The scaling factor has the syntax:  */
   /*        F[+|-]nnn                                               */
   /*      wnere {+|-}nnn has the value of -q1."  -SC26-3114-01, p.90*/
   if prec<scale | scale<0 then do;                        /*20090723*/
     if pDec->FD18=0 then do            /* Source was zero      0.9.9*/
       o = o+1;                                               /*0.9.9*/
       tmp(o)=' ';                                            /*0.9.9*/
       o = o+1;                                               /*0.9.9*/
       tmp(o)='0';                                            /*0.9.9*/
       return;                                                /*0.9.9*/
       end;                                                   /*0.9.9*/
     o = o+1;                                              /*20090723*/
     tmp(o)='F';                                           /*20090723*/
     o = o+1;                                              /*20090723*/
     if scale>=0 then do;                                  /*20090723*/
       tmp(o)='-';                                         /*20090723*/
       xscale = scale;                                     /*20090723*/
       end;                                                /*20090723*/
     else do;                                              /*20090723*/
       tmp(o)='+';                                         /*20090723*/
       xscale = -scale;                                    /*20090723*/
       end;                                                /*20090723*/
     bSig = '0'b;                      /* Significance in sca20090723*/
     do i = 2 to 0 by -1;              /* Move scale factor  20090723*/
       j = addr(xscale)->BCD_dig( d(i) );/* Get next digit   20090723*/
       c = digit(j);                   /* Get a digit        20090723*/
       if i=0 then bSig='1'b;          /* Need at least one  20090723*/
       if cª='0' | bSig                /* Include zero?      20090723*/
       then do;                                            /*20090723*/
         o=o+1;                                            /*20090723*/
         tmp(o)=c;                                         /*20090723*/
         n=n+1;                        /* Add a char                 */
         bSig='1'b;                                        /*20090723*/
         end;                                              /*20090723*/
       end; /* do i */                                     /*20090723*/
     end; /* scale */

 end convert;

 %page;

 %include BCDINC;
 %include DESC;

 end pli_CAC;
