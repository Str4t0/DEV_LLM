 /* _pli_SEARCH                                                      */
 /********************************************************************/
 /*           Iron Spring PL/I Runtime Library Version 0.9.7         */
 /*              Distributed under the Gnu LGPL License              */
 /*                                                                  */
 /*      Module:        _pli_SEARCH (PL/I runtime)                   */
 /*      Version:       1.0                                          */
 /*      Date:          Jan, 2015                                    */
 /*      Author:        Peter Flass                                  */
 /*                                                                  */
 /*      Entry Points:  _pli_SEARCH [SEARCH() BIF]                   */
 /*                                                                  */
 /*      Function:      Implement SEARCH to search for               */
 /*                     character string expressions                 */
 /*                     longer than a single character.              */
 /*                                                                  */
 /*                     The compiler generates inline code for       */
 /*                     search for a single character.               */
 /*                                                                  */
 /*      Dependencices: PL/I Locator/Descriptor formats.             */
 /*                                                                  */
 /*      Calling sequence:                                           */
 /*                     DCL search entry(pHaystk,pNeedle, iBegin )   */
 /*                                returns( fixed bin(31) )          */
 /*                                options( LINKAGE(SYSTEM) );       */
 /*                     ix = search( addr(haystack_loc_desc),        */
 /*                                  addr(needle_loc_desc,           */
 /*                                  iBegin )
 /*                                                                  */
 /*                     'Haystack' and 'Needle' are both character-  */
 /*                     string expressions.                          */
 /*                                                                  */
 /*                     Each address points to a character-string    */
 /*                     Locator/Descriptor.                          */
 /*                                                                  */
 /*      To Do:       . Since FIXED BINARY UNSIGNED is not yet       */
 /*                     implemented this procedure is written for    */
 /*                     signed.  This is a relatively small hit.     */
 /*                                                                  */
 /*      Modifications:                                              */
 /*        2017-07-14: Was returning pos of 1st character found0.9.10*/
 /*                                                                  */
 /********************************************************************/

 search: proc( pHaystack, pNeedle, iBegin )    
         returns( fixed bin(31) )
         options( LINKAGE(SYSTEM) )
         ext( '_pli_SEARCH' );

 /*-------------------------*/
 /* Parameters              */
 /*-------------------------*/
 dcl     pHaystack           ptr;       /* ->Source string loc/desc  */
 dcl     pNeedle             ptr;       /* ->Search string loc/desc  */
 dcl     iBegin              fixed bin(31);

 /*-------------------------*/
 /* Automatic Data          */
 /*-------------------------*/
 dcl    (pH,pN)              ptr;
 dcl     iPos                fixed bin(31);
 dcl    (lH,lN)              fixed bin(31);
 dcl     c                   char(1);
 dcl     min                 fixed bin(31);                  /*0.9.10*/

 dcl     Varying_String      char(0)   varying   based;
 dcl     OneC                char(1)             based;
 dcl     Max_String          char(32767)         based;

 /*-------------------------*/
 /* Static Data             */
 /*-------------------------*/
 
 dcl    (addr,index,length,stg,string,sysnull)
                             builtin;
 %page;
 /*-----------------------------------*/
 /* Get Lengths and positions         */
 /*-----------------------------------*/
 pH = pHaystack->pData;                /* Address of 'Haystack'      */
 if pHaystack->pDesc->ST_id='10'x      /* Is Haystack fixed-length?  */
 then lH=pHaystack->pDesc->ST_len;     /* .. Yes, length from descr  */
 else do;                              /* .. No, length from prefix  */
   lH = length(pH->Varying_String);
   pH = pH + stg( sysnull()->Varying_String );
   end;
 pN = pNeedle->pData;                  /* Address of 'Needle'        */
 if pNeedle->pDesc->ST_id='10'x        /* Is Needle fixed-length?    */
 then lN=pNeedle->pDesc->ST_len;       /* .. Yes, length from descr  */
 else do;                              /* .. No, length from prefix  */
   lN = length(pN->Varying_String);
   pN = pN + stg( sysnull()->Varying_String );
   end;

 if lN=0 | lH=0 then return(0);        /* Zero-length string         */
 if iBegin<0                           /* Check starting position    */
 then signal STRINGRANGE;              /* Manual doesn't say optional*/
 if iBegin>lH then return(0);          /* Past end of string         */
 pH = pH+iBegin;                       /* String start address       */
 lH = lH-iBegin;                       /* Remaining string length    */
 
 /*-----------------------------------*/
 /* Search the string                 */
 /* Look for characters in Needle     */
 /* one at a time                     */
 /*-----------------------------------*/
 min = lH+1;                                                 /*0.9.10*/
 do while( lN>0 );
   c = pN->OneC;                       /* Get first character        */
   iPos = INDEX( substr(pH->Max_String,1,lH), c );
   if iPos>0 then do;                  /* If found             0.9.10*/
     if iPos<min then min=iPos;        /*   save pos of 1st occ0.9.10*/
     end;                                                    /*0.9.10*/
   pN = pN+1;                          /* Continue                   */
   lN = lN-1;
   end; /* do while */

 if min=lH+1 then min=0;               /* Not found            0.9.10*/
 return(min);                                                /*0.9.10*/

 return(0);                            /* Not found                  */

 %page;
 %include DESC;
 %include LOCDESC;

 end search;
