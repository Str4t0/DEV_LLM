 /* _pli_Adj                                                         */
 /********************************************************************/
 /*           Iron Spring PL/I Runtime Library Version 0.9.6         */
 /*              Distributed under the Gnu LGPL License              */
 /*                                                                  */
 /*      Module:        _pli_Adj (PL/I runtime)                      */
 /*      Version:       1.0                                          */
 /*      Date:          Jan, 2015                                    */
 /*      Author:        Peter Flass                                  */
 /*                                                                  */
 /*      Entry Points:  _pli_Subsc                                   */
 /*                     _pli_ANext                                   */
 /*                     _pli_ACmp                                    */
 /*                     _pli_ACnt                                    */
 /*                                                                  */
 /*      Function:      Functions for adjustable arrays              */
 /*                                                                  */
 /*      Dependencies:                                               */
 /*                     PL/I descriptor formats.                     */
 /*                                                                  */
 /*      Calling sequence:                                           */
 /*                                                                  */
 /*          offset = Subsc( pDesc, pSubs );                         */
 /*            Returns the offset of an array element based on a     */
 /*            list of subscripts.                                   */
 /*              pDesc is the address of the array descriptor        */
 /*              pSubs is the address of a list containing the       */
 /*                number of subscripts followed by the values.      */
 /*                (see entry point for format)                      */
 /*                                                                  */
 /*          call ACmp( pDesc1, pDesc2 );                            */
 /*            Compares the bounds to two arrays.   If not equal     */
 /*            raises the ERROR condition.                           */
 /*              pDesc1 and pDesc2 are the addresses of the array    */
 /*                descriptors to be compared. This is intended to   */
 /*                be used for adjustable arrays, but should work    */
 /*                with any array.                                   */
 /*                                                                  */
 /*                                                                  */
 /*          RC = ANext( pDesc, pSubs )                              */
 /*            Increments a subscript list to point to the next      */
 /*            element.                                              */
 /*              pDesc is the address of the array descriptor        */
 /*              pSubs is the address of a list containing the       */
 /*                number of subscripts followed by the values.      */
 /*                (see entry point for format)                      */
 /*              If the number of subscripts in pSubs is negative    */
 /*              the array is initialized to all lower bounds.       */
 /*              Returns 1 if more elements to be processed.         */
 /*              Returns 0 after the last element.                   */
 /*                                                                  */
 /*          n  = ACnt( pDesc )                                      */
 /*            Returns the number of elements in the adjustable      */
 /*            array identified by pDesc.                            */
 /*                                                                  */
 /*      To Do:                                                      */
 /*         * Does not currently handle bit subscripting. Look at    */
 /*           AGGIO for example of what to do.                       */
 /*                                                                  */
 /*      Modifications:                                              */
 /*        2025-03-23: Added ACnt entry.                        1.3.3*/
 /*        2024-04-07: Normalize subscripts                     1.3.0*/
 /*        2024-02-26: Number of dimensions not being set       1.2.1*/
 /*        2020-03-18: Kludge for adjustable arrays           0.9.10c*/
 /*                                                                  */
 /********************************************************************/
 
 pli_Adj: package exports(pli_Subsc,pli_ACmp,pli_ANext,       /*0.9.7*/
                          pli_ACnt );                         /*1.3.3*/
                   
 /*-------------------------*/
 /* Static Data             */
 /*-------------------------*/
 /* (none) */

 /*-------------------------*/
 /* Prototypes              */
 /*-------------------------*/
 /* (none) */

 /*-------------------------*/
 /* External Entries        */
 /*-------------------------*/
 dcl     GetFlags            entry
                             external( '_pli_GetFlags' )
                             returns( bit(16) )
                             options( LINKAGE(SYSTEM) );
 dcl     SetFlags            entry( bit(16) )               /*0.9.10e*/
                             ext( '_pli_SetFlags' )         /*0.9.10e*/
                             options( linkage(system) );    /*0.9.10e*/
 
 dcl    (addr,null,plifill,plimove,stg,string,sysnull)
                             builtin;

%page;			     
 /********************************************************************/
 /*      Entry:         _pli_Subsc (PL/I runtime)                    */
 /*                                                                  */
 /*      Function:      Subscripting adjustable/non-connected arrays */
 /*                                                                  */
 /*      Subsc is called to compute an offset for a subscript list   */
 /*      for arrays whenever simple subscripting is impossible.      */
 /*      These should be multi-dimensional arrays or arrays of       */
 /*      structures containing adjustable elements                   */
 /*      [length determined at run-time, like CHAR(*)].              */
 /*      It is passed the address of the array or structure          */
 /*      descriptor and a of a list of subscript values.             */
 /*      The computed offset is returned.                            */
 /*                                                                  */
 /*      The subscripts are updated by one each time called.         */
 /*                                                                  */
 /*      Dependencices:                                              */
 /*                     Descriptor formats.                          */
 /*                                                                  */
 /*      Argument List:                                              */
 /*             +--------------------------------+                   */
 /*         +00 | addr(descriptor)               |                   */
 /*             +--------------------------------+                   */
 /*         +04 | Addr(subscript list)           | --+               */
 /*             +--------------------------------+   |               */
 /*                                                  |               */
 /*      Subscript List:                             |               */
 /*             +--------------------------------+   |               */
 /*         +00 | Number of subscripts           | <-+               */
 /*             +--------------------------------+                   */
 /*         +04 | Subscript 1 Value              |                   */
 /*             +--------------------------------+                   */
 /*             | ...                            |                   */
 /*                                                                  */
 /*      Errors:        SUBSCRIPTRANGE (if enabled).                 */
 /*                                                                  */
 /*      To Do:                                                      */
 /*        Any special considerations for UNALIGNED BIT arrays?      */
 /*                                                                  */
 /*      Modifications:                                              */
 /*          2024-04-07: Normalize subscript                    1.3.0*/
 /*          2016-10-06: Computation of RVO incorrect for      0.9.10*/
 /*                      elements of arrays of structures.     0.9.10*/
 /*          2015-01-02: Change calling sequence and add logic  0.9.7*/
 /*                      to update subscripts after call.       0.9.7*/
 /*          2013-01-10: "Zero-day" fixes.                      0.9.4*/
 /*                                                                  */
 /********************************************************************/

 pli_Subsc: proc(pDesc,pSubsX)                                 /*0.9.7*/
              returns( fixed bin(31) )
              options( linkage(system) )
              ext( '_pli_Subsc' );

 /*-------------------------*/
 /* Parameters              */
 /*-------------------------*/
 dcl     pDesc               ptr;      /* ->Descriptor          0.9.7*/
 dcl     pSubsX              ptr;      /* ->Subscript list      0.9.7*/
 dcl     pSubs               ptr;                             /*0.9.7*/

 dcl   1 Sublist             based( pSubs ),                  /*0.9.7*/
         5 nSub              fixed bin(31), /* Number of subscripts  */
         5 iSub           (1)fixed bin(31); /* Subscript values      */
         /* 'iSub' repeats 'nSub' times.                             */

 /*-------------------------*/
 /* Automatic Data          */
 /*-------------------------*/
 dcl     pD                  ptr;
 dcl     pDx                 ptr;
 dcl     offset              fixed bin(31);
 dcl     i                   fixed bin(31);
 dcl     n                   fixed bin(31);
 dcl     p                   ptr;                             /*0.9.7*/
 dcl     bSUBRG              bit(1)              init( '0'b );

 %include CONDMASK;

 /*-------------------------------------------------------*/
 /* Composite subscript data for arrays of structures     */
 /*-------------------------------------------------------*/
 dcl   1 CompositeSubs       unaligned,
         5 CompArray         like pli_ded_ARR,
         5 CompDim       (15)like pli_ded_Dim;
         /* COMMENT '(15)' is 'max_dim'                   */

 /*-------------------------------------------------------*/
 /*  Mainline -- process all descriptors                  */
 /*-------------------------------------------------------*/
 string(cond_mask) = GetFlags();       /* Get enabled conditions     */
 M_LibMod = '1'b;                      /* Indicate 'Library'  0.9.10e*/
 call SetFlags( string(cond_mask) );   /* Set for called rtn  0.9.10e*/

 pD = pDesc;                           /* Addr(descriptor)           */
 
 /*-----------------------------------*/                      /*0.9.7*/
 /* Fix to make programs compiled     */                      /*0.9.7*/
 /* for the previous version work.    */                      /*0.9.7*/
 /*-----------------------------------*/                      /*0.9.7*/
 pSubs = pSubsx;
 if binvalue(pSubs)>=-15 &             /* pSubs is actually nSub0.9.7*/
    binvalue(pSubs)<=15                                       /*0.9.7*/
 then pSubs = addr(pSubsx);            /* ->Old format arg list 0.9.7*/
 
 /* The descriptor will be the address of the array descriptor for   */
 /* a non-structure, or the address of the structure descriptor for  */
 /* a structure.                                                     */
 /* If this is an array of structures, the array descriptor will     */
 /* appear first, followed by the structure descriptor.              */
 
 call get_composite_subsc( pD, addr(CompositeSubs) ); 

 /*-------------------------------------------------------*/
 /*  Subscript computations. Compiled code guarantees     */
 /*  that the number of subscripts (nSub) will be         */
 /*  less than or equal to the number of dimensions.      */
 /*  pD points either directly to the array descriptor    */
 /*  or to the composite subscripts.                      */
 /*-------------------------------------------------------*/
 nSub = CompArray.ar_dim;                                     /*1.2.1*/
 offset = 0; 
 do i=1 to nSub;
   n = iSub(i);                        /* Get the subscript          */
   if n<CompDim.DM_lbnd(i) |           /* Check for bad subscript    */
      n>CompDim.DM_hbnd(i)
   then bSUBRG = '1'b;                 /* SUBSCRIPTRANGE if enabled  */
   n = n-CompDim.DM_lbnd(i);         /* Normalize subscript   1.3.0*/
   n = n * CompDim.DM_mult(i); 
   offset = offset + n;                /* Accumulate offsets         */
   end; /* do i */

 return(offset);                                              /*1.3.0*/
/* offset = offset -                     /* Sub RVO            20070329*/
/*          CompArray.AR_rvo;            /*                      0.9.10*/
 
 /*-------------------------------------------------------*/
 /*  Check for SUBSCRIPTRANGE if enabled                  */
 /*-------------------------------------------------------*/
 if bSUBRG & M_Subscriptrange
 then signal SUBSCRIPTRANGE;           /* Normal return to next stmt */

 return(offset);                       /* Return subscript value     */   

 end pli_Subsc;
                   
%page;
 /********************************************************************/
 /*      Entry:         _pli_ACmp  (PL/I runtime)                    */
 /*                                                                  */
 /*      Function:      Compare bounds of adjustable arrays          */
 /*                                                                  */
 /*      ACmp is called to compare bounds of two arrays involved     */
 /*      in aggregate array operations.  The number of dimensions    */
 /*      and the lower and upper bounds must be equal or the ERROR   */
 /*      condition is raised.  Otherwise the procedure returns       */
 /*      normally.                                                   */
 /*                                                                  */
 /*      Dependencices:                                              */
 /*                     Descriptor formats.                          */
 /*                                                                  */
 /*      Errors:        ERROR                                        */
 /*                                                                  */
 /*      To Do:                                                      */
 /*                                                                  */
 /*      Modifications:                                              */
 /*        2021-07-03: Non-matching arrays raises SUBRG       0.9.10e*/
 /*                                                                  */
 /********************************************************************/

 pli_ACmp:  proc(pDesc1,pDesc2)                               /*0.9.7*/
              options( linkage(system) )
              ext( '_pli_ACmp' );

 /*-------------------------*/
 /* Parameters              */
 /*-------------------------*/
 dcl    (pDesc1,pDesc2)      ptr;      /* ->Descriptors         0.9.7*/

 /*-------------------------*/
 /* Automatic Data          */
 /*-------------------------*/
 dcl    (pD1,pD2)            ptr;
 dcl     pDx                 ptr;
 dcl     i                   fixed bin(31);

 /*-------------------------------------------------------*/
 /* Composite subscript data for arrays of structures     */
 /*-------------------------------------------------------*/
 dcl   1 CompositeSubs1      unaligned,
         5 CompArray1        like pli_ded_ARR,
         5 CompDim1      (15)like pli_ded_Dim;
         /* COMMENT '(15)' is 'max_dim'                   */
 dcl   1 CompositeSubs2      unaligned,
         5 CompArray2        like pli_ded_ARR,
         5 CompDim2      (15)like pli_ded_Dim;
         /* COMMENT '(15)' is 'max_dim'                   */

 %include CONDMASK;

 /*-------------------------------------------------------*/
 /*  Mainline -- process all descriptors                  */
 /*-------------------------------------------------------*/
 string(cond_mask) = GetFlags();       /* Get enabled conditions     */
 M_LibMod = '1'b;                      /* Indicate 'Library'  0.9.10e*/
 call SetFlags( string(cond_mask) );   /* Set for called rtn  0.9.10e*/
    
 pD1 = pDesc1;
 pD2 = pDesc2;

 /* The descriptor will be the address of the array descriptor for   */
 /* a non-structure, or the address of the structure descriptor for  */
 /* a structure.                                                     */
 /* If this is an array of structures, the array descriptor will     */
 /* appear first, followed by the structure descriptor.              */
 
 call get_composite_subsc( pD1, addr(CompositeSubs1) );                    
 pD1 = addr(CompositeSubs1);
 call get_composite_subsc( pD2, addr(CompositeSubs2) );                    
 pD2 = addr(CompositeSubs2);
   
 /*------------------------------*/
 /* Now compare the bound info   */
 /*------------------------------*/
 if CompArray1.AR_dim ^= CompArray2.AR_dim   /* Just in case, S.N.O. */
 then goto raise_error;
 do i=1 to CompArray1.AR_dim;
   /* Adjustable array. NOTE: This is sloppy, should be in des       */
   if CompDim1.DM_lbnd(i) = 1 &                             /*0.9.10c*/
      CompDim1.DM_hbnd(i) =0 then /*continue*/ ;            /*0.9.10c*/
   else if CompDim1.DM_lbnd(i) ^= CompDim2.DM_lbnd(i) |
           CompDim1.DM_hbnd(i) ^= CompDim2.DM_hbnd(i)
        then goto raise_error;    
   end; /* do i */
 return;                                /* Match                      */
 
 /*------------------------------*/
 /* Arrays do not match          */
 /*------------------------------*/
 raise_error:
   if M_Subscriptrange                                      /*0.9.10e*/
   then signal SUBSCRIPTRANGE;                              /*0.9.10e*/
   signal ERROR;                        /* Normal return from SUBRG e*/
   /* control never returns here */  

 end pli_ACmp; 
 %page;
    
 /********************************************************************/
 /*      Entry:         _pli_ANext (PL/I runtime)                    */
 /*                                                                  */
 /*      Function:      Subscripting adjustable arrays.              */
 /*                                                                  */
 /*      aNext initializes or increments a list of subscripts        */
 /*      of an adjustable array.                                     */
 /*                                                                  */
 /*      Dependencices:                                              */
 /*                     Descriptor formats.                          */
 /*                                                                  */
 /*      Argument List:                                              */
 /*             +--------------------------------+                   */
 /*         +00 | addr(descriptor)               |                   */
 /*             +--------------------------------+                   */
 /*         +04 | Addr(subscript list)           | --+               */
 /*             +--------------------------------+   |               */
 /*                                                  |               */
 /*      Subscript List:                             |               */
 /*             +--------------------------------+   |               */
 /*         +00 | Number of subscripts           | <-+               */
 /*             +--------------------------------+                   */
 /*         +04 | Subscript 1 Value              |                   */
 /*             +--------------------------------+                   */
 /*             | ...                            |                   */
 /*                                                                  */
 /*      To Do:                                                      */
 /*                                                                  */
 /*      Modifications:                                              */
 /*                                                                  */
 /********************************************************************/

 pli_ANext: proc(pDesc,pSubs)                                 /*0.9.7*/
              returns( fixed bin(31) )
              options( linkage(system) )
              ext( '_pli_ANext' );

 /*-------------------------*/
 /* Parameters              */
 /*-------------------------*/
 dcl     pDesc               ptr;      /* ->Descriptor          0.9.7*/
 dcl     pSubs               ptr;                             /*0.9.7*/

 dcl   1 Sublist             based( pSubs ),                  /*0.9.7*/
         5 nSub              fixed bin(31), /* Number of subscripts  */
         5 iSub           (1)fixed bin(31); /* Subscript values      */
         /* 'iSub' repeats 'nSub' times.                             */
 
 /*-------------------------*/
 /* Automatic Data          */
 /*-------------------------*/
 dcl     pD                  ptr;
 dcl     i                   fixed bin(31);
 /*-------------------------*/
 /* STATIC Data             */
 /*-------------------------*/
 %include CONDMASK;

 /*-------------------------------------------------------*/
 /* Composite subscript data for arrays of structures     */
 /*-------------------------------------------------------*/
 dcl   1 CompositeSubs       unaligned,
         5 CompArray         like pli_ded_ARR,
         5 CompDim       (15)like pli_ded_Dim;
         /* COMMENT '(15)' is 'max_dim'                   */

 string(cond_mask) = GetFlags();       /* Get enabled conditions     */

 pD = pDesc;                           /* Addr(descriptor)           */
 /* The descriptor will be the address of the array descriptor for   */
 /* a non-structure, or the address of the structure descriptor for  */
 /* a structure.                                                     */
 /* If this is an array of structures, the array descriptor will     */
 /* appear first, followed by the structure descriptor.              */
 
 call get_composite_subsc( pD, addr(CompositeSubs) );                    
 pD = addr(CompositeSubs);

/*--------------------------------------------------------*/
/* if nSub<0 initialize subscript list to lower bounds    */
/* COMMENT: nSub is assumed to be a valid value           */
/*--------------------------------------------------------*/
if nSub < 0 then do;
  nSub = -nSub;              /* Set number of dim         */
  do i=1 to nSub;            /* Set lower bounds          */      
    iSub(i) = CompDim(i).DM_lbnd;
    end;
  return(0);
  end; /* nSub=0 */       

 /*-------------------------------------------------------*/  /*0.9.7*/
 /*  Update subscript list                                */  /*0.9.7*/
 /*-------------------------------------------------------*/  /*0.9.7*/
 do i=nSub to 1 by -1;                                        /*0.9.7*/
   iSub(i) = iSub(i) + 1;                                     /*0.9.7*/
   if iSub(i)<=CompDim(1).DM_hbnd                             /*0.9.7*/
   then leave;                                                /*0.9.7*/
   if i=1 then return(1);
   iSub(i) = CompDim(i).DM_lbnd;                              /*0.9.7*/
   end; /* do i */                                            /*0.9.7*/
   
 return(0);                            /* More to do            0.9.7*/   

 end pli_ANext;
%page;
    
 /********************************************************************/
 /*      Entry:         _pli_ACnt  (PL/I runtime)                    */
 /*                                                                  */
 /*      Function:      Return the number of elements in an array    */
 /*                     with adjustable bounds.                      */
 /*                                                                  */
 /*      Dependencices:                                              */
 /*                     Descriptor formats.                          */
 /*                                                                  */
 /*      Argument List:                                              */
 /*             +--------------------------------+                   */
 /*         +00 | addr(descriptor)               |                   */
 /*             +--------------------------------+                   */
 /*                                                                  */
 /*      To Do:                                                      */
 /*                                                                  */
 /*      Modifications:                                              */
 /*                                                                  */
 /********************************************************************/

 pli_ACnt: proc(pDesc)                                        /*1.3.3*/
           returns( fixed bin(31) )
           options( linkage(system) )
           ext( '_pli_ACnt' );      

 /*-------------------------*/
 /* Parameters              */
 /*-------------------------*/
 dcl     pDesc               ptr;      /* ->Descriptor          0.9.7*/

 /*-------------------------*/
 /* Automatic Data          */
 /*-------------------------*/
 dcl     pD                  ptr;
 dcl     i                   fixed bin(31);
 dcl     elem                fixed bin(31);

 /*-------------------------*/
 /* STATIC Data             */
 /*-------------------------*/
 %include CONDMASK;

 /*-------------------------------------------------------*/
 /* Composite subscript data for arrays of structures     */
 /*-------------------------------------------------------*/
 dcl   1 CompositeSubs       unaligned,
         5 CompArray         like pli_ded_ARR,
         5 CompDim       (15)like pli_ded_Dim;
         /* COMMENT '(15)' is 'max_dim'                   */

 string(cond_mask) = GetFlags();       /* Get enabled conditions     */

 pD = pDesc;                           /* Addr(descriptor)           */
 /* The descriptor will be the address of the array descriptor for   */
 /* a non-structure, or the address of the structure descriptor for  */
 /* a structure.                                                     */
 /* If this is an array of structures, the array descriptor will     */
 /* appear first, followed by the structure descriptor.              */
 
 call get_composite_subsc( pD, addr(CompositeSubs) );                    
 pD = addr(CompositeSubs);

 /*-------------------------------------------------------*/ 
 /*  Count elements                                       */ 
 /*-------------------------------------------------------*/
 elem = CompArray.AR_dim;          /* Init count to 1 per dimension  */
 do i=1 to CompArray.AR_dim;
   elem = elem + CompDim.DM_hbnd(i) - CompDim.DM_lbnd(i);  
   end; /* do i */                                           
   
 return(elem);    

 end pli_ACnt;                                                /*1.3.3*/

%page;
 /*-------------------------------------------------------*/
 /*  Process Structure descriptor (internal procedure)    */
 /*-------------------------------------------------------*/
 get_composite_subsc: proc( pD, pComp );
   dcl   pD                  ptr;      /* ->Descriptor               */
   dcl   pComp               ptr;      /* ->Workarea                 */
   dcl   pS                  ptr;      /* ->SEDs                     */
   dcl   pX                  ptr;      /* ->Composite dimensions     */
   dcl   pE                  ptr;      /* ->Struct Elem descriptor   */
   dcl   n                   fixed bin(31);
   dcl   StartingLevel       fixed bin(31); /* Srtaing level number  */
   dcl   bFirst              bit(1);                          /*0.9.4*/
   
   dcl 1 CompositeSubs       unaligned based(pComp),
         5 CompArray         like pli_ded_ARR,
         5 CompDim       (15)like pli_ded_Dim;
         /* COMMENT '(15)' is 'max_dim'                   */

   pX = addr(CompArray.AR_dims);       /* ->Composite dimensions     */
   call PLIFILL( addr(CompArray), '00'x,/* Clear Composite Subscripts*/
                 stg(NULL()->pli_ded_ARR) );
   /* Check for array                 */
   if pD->SD_id = '30'x then do;       /* Array                      */
     n = pD->pli_ded_ARR.AR_dim;       /*   Capture top-level        */
     CompArray.AR_dim = n;             /*   array data               */
     CompArray.AR_rvo = pD->pli_ded_ARR.AR_rvo;               /*0.9.4*/
     n = n*stg(null()->pli_ded_Dim);
     call PLIMOVE( pX, addr(pD->pli_ded_ARR.ar_dims), n );
     return;
     end; /* array */

   if pD->SD_id = '80'x                /* Structure             0.9.4*/
   then pS = pD->SDD_pSED;             /* ->First SED           0.9.4*/
   else return;

   StartingLevel = pS->SE_lvl;         /* Save starting level number */
   bFirst = '1'b;                                             /*0.9.4*/
   /* The SDD may point to a minor structure.  We need to save       */
   /* the starting level number, and terminate when a level          */
   /* less than or equal to this is encountered.                     */

   do while( '1'b );                   /* Do entire structure        */
     pE = pS->SE_desc;                 /* ->Element_Descriptor       */
     if pS->SE_array then do;          /* Is this array?             */
       n = pE->pli_ded_ARR.AR_dim;     /* Yes, get array data        */
       if bFirst then do;              /* First dimension       0.9.4*/
         CompArray.AR_rvo = pE->pli_ded_ARR.AR_rvo;           /*0.9.4*/
	 bFirst = '0'b;                                       /*0.9.4*/
	 end;                                                 /*0.9.4*/
       CompArray.AR_dim = CompArray.AR_dim + n;
       n = n*stg(null()->pli_ded_Dim);
       call PLIMOVE( pX, addr(pE->pli_ded_ARR.ar_dims), n );
       pX = pX+n;
       end; /* array */
     if pS->SE_last then leave;        /* Last SED processed         */
     pS = addr(pS->SE_end);            /* ->Next SED                 */
     if pS->SE_lvl<=StartingLevel      /* End of minor structure     */
     then leave;
     end; /* do while */
   end get_composite_subsc;

 %page;
 %include desc;

 end pli_Adj;  
