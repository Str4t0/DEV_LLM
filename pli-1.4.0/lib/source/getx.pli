*process trc('      7');
 /* _pli_Getx                                                        */
 /********************************************************************/
 /*           Iron Spring PL/I Runtime Library Version 0.5           */
 /*              Distributed under the Gnu LGPL License              */
 /*                                                                  */
 /*      Module:        _pli_Getx (PL/I runtime)                     */
 /*      Version:       2.0                                          */
 /*      Date:          Jan, 2007                                    */
 /*                     Version 2.0 Aug, 2017                        */
 /*      Author:        Peter Flass                                  */
 /*                                                                  */
 /*      Entry Points:  _pli_GetX                                    */
 /*                                                                  */
 /*      Function:      Get is the stream input executor.            */
 /*                                                                  */
 /*      GetX is called from Get or GetS once per data element       */
 /*      to be read.  It is passed a single argument, the            */
 /*      'GET/PUT STRING BLOCK' (GPSB) built by the caller.          */
 /*      GetX will process until:                                    */
 /*        1) Last data element processed.                           */
 /*        2) Input buffer (string) empty                            */
 /*        3) Control format item (PAGE,SKIP,etc.) encountered.      */
 /*      In cases 2 and 3 it will call a procedure indicated by      */
 /*      the caller to take appropriate action.                      */
 /*                                                                  */
 /*      Dependencices:                                              */
 /*                     PL/I descriptor formats.                     */
 /*                     ENTRY VARIABLE format.                       */
 /*                                                                  */
 /*      Calling sequence:                                           */
 /*                                                                  */
 /*      To Do:                                                      */
 /*        * Looks like 'encode_num' can be deleted.                 */
 /*        * ''b3 bit strings                                        */
 /*        * GET DATA not implemented                                */
 /*        * Need ONFILE                                             */
 /*        * Provide run-time method of enabling debug displays      */
 /*                                                                  */
 /*      Modifications:                                              */
 /*        2024-07-29: Fix CONVERSION for GET LIST              1.3.1*/
 /*        2024-02-27: Pass data needed for iSub arrays         1.2.1*/
 /*        2024-02-27: Chg aggio calls, GET EDIT structure.     1.2.1*/
 /*        2024-02-21: Pass data needed for iSub arrays         1.2.1*/
 /*        2022-06-08: B4 format, B3 format                     1.0.0*/
 /*                    Fix handling of CONVERSION               1.0.0*/
 /*        2018-01-19: Fix array input, B- and P-Format       0.9.10b*/
 /*        2017-08-15: Allow tabs as separators in get list    0.9.10*/
 /*        2017-08-01: Use AggIO for arrays and structures     0.9.10*/
 /*        2016-06-11: W82, GET STRING LIST traps on last item 0.9.10*/
 /*        2015-07-23: A-fmt input traps if width not spec(w69  0.9.9*/
 /*        2015-07-23: Trap with L-Format if line_length=0 (w68   9.9*/
 /*        2014-03-05: Fixes for varying character input        0.9.5*/
 /*        2012-07-09: L-format (quick and dirty)               0.9.3*/
 /*        2009-09-22: Fix problems with ENDFILE.                0.8c*/
 /*        2009-09-21: A final character string in a file being  0.8c*/
 /*                    read using 'GET LIST' is not read if      0.8c*/
 /*                    the terminating quote is the last         0.8c*/
 /*                      character in the file.                  0.8c*/
 /*                                                                  */
 /********************************************************************/

 pli_Getx: proc( xpParm )
               ext( '_pli_GetX' );

 /*-------------------------*/
 /* Parameters              */
 /*-------------------------*/
 dcl     xpParm              ptr;      /* -> GETX parameter list     */

 /*-------------------------*/
 /* Static Data             */
 /*-------------------------*/
 dcl     UNIMPLEMENTED       condition;                       /*1.2.1*/
 dcl     Blanks              char(32)  static    init('');
 dcl     TAB                 char(1)   static    init('09'x);/*0.9.10*/
 dcl     HexChar             char(22)  static                  /*0.7c*/
             init( '0123456789ABCDEFabcdef' );                 /*0.7c*/
 dcl     OctChar             char(8)   static                 /*1.0.0*/
             init( '01234567' );                              /*1.0.0*/
 dcl     digits              char(10)  static                  /*0.7c*/
             init( '0123456789' );                             /*0.7c*/
 dcl     no_name             char(1)   static var init('');   /*1.2.1*/

 /* PUT statement option bits (from GIO)        */
 dcl     bEdit               bit(32)   static    init('00004000'bx);
 dcl     bData               bit(32)   static    init('00002000'bx);
 dcl     bList               bit(32)   static    init('00001000'bx);

 /*-------------------------*/
 /* Automatic Data          */
 /*-------------------------*/
 dcl     pParm               ptr;      /* -> Parameter List          */
 dcl   1 PL                  like SPL   based(pParm);

 dcl     pData               ptr;      /* -> Data element            */
 dcl     pDesc               ptr;      /* -> Data descriptor         */
 dcl     pName               ptr;      /* -> Data name       20080409*/
 dcl     pSRB                ptr;      /* -> SRB                     */
 dcl     pSBB                ptr;      /* -> SBB                     */
 dcl     Count               fixed bin(31);
 dcl     char_workarea       char(64);
         /* This field needs to be as long as the largest possible   */
         /* complex converted data-element.                          */
         /* 64 is a made-up placeholder.                             */
 dcl     num_workarea     (2)fixed dec(18);
 dcl     desc_workarea       char(16);
         /* This field needs to be as long as the largest possible   */
         /* converted descriptor.                                    */
         /* 16 is a made-up placeholder.                             */
 dcl     field_width         fixed bin(31);
 dcl     data_width          fixed bin(31);
 dcl     error_code          char(1)              init(' '); /*0.9.10*/
 dcl   1 conv_parms,                    /* Parm list for CONV   1.0.0*/
         5 conv_onsource      ptr,      /* ONSOURCE             1.0.0*/
         5 conv_onchar        ptr,      /* ONCHAR               1.0.0*/
         5 conv_onfile        ptr;      /* ONFILE or sysnull()  1.0.0*/
                   
 %include CONDMASK;

 /*-------------------------*/
 /* Prototypes              */
 /*-------------------------*/
 dcl     FD18                fixed dec(18) based;
 dcl     FB31                fixed bin(31) based;
 dcl     FB15                fixed bin(15) based;
 dcl     FB7                 fixed bin(7)  based;
 dcl     pVoid               ptr           based;
 dcl     VarStr              char(0)       based varying;
 dcl     VarStrLen           fixed bin(15) based;
 dcl     C1                  char(1)       based;              /*0.7c*/
 dcl     B8                  bit(8)        based;           /*0.9.10b*/

 /*-------------------------*/
 /* External Entries        */
 /*-------------------------*/
 dcl     GetFlags            entry                            /*1.2.1*/
                             external( '_pli_GetFlags' )      /*1.2.1*/
                             returns( bit(16) )               /*1.2.1*/
                             options( LINKAGE(SYSTEM) );      /*1.2.1*/
 dcl     SetFlags            entry( bit(16) )
                             ext( '_pli_SetFlags' )
                             options( linkage(system) );
 dcl     Format              entry( ptr )
                             external( '_pli_Fmt' );
 dcl     NPI                 entry( ptr, ptr )              /*0.9.10b*/
                             returns( fixed dec(18) )       /*0.9.10b*/
                             options( linkage(system) )     /*0.9.10b*/ 
                             external( '_pli_NPI' );        /*0.9.10b*/
 dcl     NPO                 entry( ptr, bit(32), ptr, ptr )
                             options( linkage(system) )
                             external( '_pli_NPO' );
 dcl     CBA                 entry( ptr, ptr )
                             returns( fixed bin(31) )       /*0.9.10b*/
                             options( linkage(system) )
                             external( '_pli_CBA' );
 dcl     CBD                 entry( ptr, ptr, ptr, ptr )
                             options( linkage(system) )
                             external( '_pli_CBD' );
 dcl     CCA                 entry( ptr, ptr, ptr, ptr, ptr )
                             options( linkage(system) )
                             external( '_pli_CCA' );
 dcl     CCB                 entry( ptr, ptr, ptr )         /*0.9.10b*/
                             returns( fixed bin(31) )         /*1.0.0*/
                             options( linkage(system) )     /*0.9.10b*/
                             external( '_pli_CCB' );        /*0.9.10b*/
 dcl     CAC                 entry( ptr, ptr, ptr )
                             options( linkage(system) )
                             external( '_pli_CAC' );
 dcl     NumVal              entry( ptr, ptr, ptr, ptr )       /*0.7c*/
                             options( linkage(system) )        /*0.7c*/
                             external( '_pli_NumVal' );        /*0.7c*/
 dcl     Cnvt                entry( ptr, ptr, ptr, ptr )       /*0.7c*/
                             options( linkage(system) )        /*0.7c*/
                             external( '_pli_Cnvt' );          /*0.7c*/
 dcl     FmtSub              entry( ptr, ptr, ptr )          /*0.9.10*/
                             options( linkage(system) )      /*0.9.10*/
                             ext( '_pli_FmtSub' );           /*0.9.10*/
 dcl     AggIO               entry( ptr, ptr, ptr, entry,    /*0.9.10*/
                             /* optional*/    ptr, ptr )      /*1.2.1*/
                             ext( '_pli_AggIO' );            /*0.9.10*/
 dcl     GetD                entry( ptr, ptr, ptr )          /*0.9.10*/
                             ext( '_pli_GetD' );             /*0.9.10*/
 dcl     CONV                entry( fixed bin(31), ptr )      /*1.0.0*/
                             returns( ptr )                   /*1.0.0*/
                             ext( '_pli_Conv' )               /*1.0.0*/
                             options( linkage(system) );      /*1.0.0*/

 dcl    (
         addr,length,
         plimove,ptrvalue,
         stg,string,substr,
         sysnull
        )                    builtin;

 /*------------------------------------------------------------------*/
 /* Procedure entry, save a few items for efficiency.                */
 /*------------------------------------------------------------------*/
 pParm = xpParm; 
 pSRB  = pParm->PL.SPL_pSRB; /* -> Stream Request Block              */
 pSBB  = pParm->PL.SPL_pSBB; /* -> Stream Buffer Block               */
 pData = pSRB->SRB_pData;    /* -> Data Element or SYSNULL           */
 pDesc = pSRB->SRB_pDesc;    /* -> Data Descriptor or SYSNULL        */
 pName = pSRB->SRB_pName;    /* -> Data Name or SYSNULL      20080409*/
 PL.SPL_Count  = 0;          /* Initialize COUNT for this GET        */
 conv_onsource = addr(pSRB->SRB_pData); /* Set up for signal_con1.0.0*/
 conv_onfile   = sysnull;    /* NOTE: Fix later                      */

 /*------------------------------------------------------------------*/
 /* COMMENT: Set the condition flags in the DSA so that any          */
 /*          called routines will have the correct values.           */
 /*------------------------------------------------------------------*/
 string(cond_mask) = pSRB->SRB_condmask;    /* Callers enabled cond. */
 M_LibMod = '1'b;                           /* Indicate Library 1.3.1*/
 call SetFlags( string(cond_mask) );        /* Set for called rtns   */

 /*---------------------------------------------*/
 /* Check for DATA, EDIT, or LIST               */
 /*---------------------------------------------*/
 if (pSRB->SRB_bOpt&bData)ª='00000000'bx /* GET DATA         */
 then call Data;
 if (pSRB->SRB_bOpt&bEdit)ª='00000000'bx /* GET EDIT         */
 then call Edit;
 if (pSRB->SRB_bOpt&bList)ª='00000000'bx /* GET LIST         */
 then call List;
 return;
 
 /*---------------------------------------------*/
 /* Error-handling                              */
 /* Formats C, E, G                             */
 /*---------------------------------------------*/
 signal_unimplemented:
   signal condition( UNIMPLEMENTED );
   return;

 signal_error:
   /*display( 'getx error code=' || error_code ); /**/
   /* There isn't a lot of logic or consistency     */
   /* in these codes, they're internal diagnostics  */
   /* only.                                         */
   /* 1=format problem?                             */
   /* 2=try to read program control data            */
   /* 3=error reading string                        */
   /* 4=get list(string) requires quotes            */
   /* 5=try to read program control data            */
   /* 6=data conversion error                       */
   signal ERROR;
   /* No normal return from ERROR */

 /*---------------------------------------------*/
 /* X Format-Item                               */
 /*---------------------------------------------*/
 x: proc(n);                 /* X[(n)]                               */
   dcl   n                   fixed bin(31);
   dcl  (i,j)                fixed bin(31);
   i = n;
   do while( i>0 );          /* move spaces in chunks of up to 32b   */
     j = min( i, stg(Blanks) );                            /*20090922*/
     call move_from_buffer( addr(Blanks), j );
     i = i-j;
     end; /* do while */
   end x;

 /*---------------------------------------------*/
 /* Move data to temporary buffer               */
 /*---------------------------------------------*/
 move_from_buffer: proc(where,howmuch);
   dcl   where               ptr;
   dcl   howmuch             fixed bin(31);
   dcl  (i,n)                fixed bin(31);
   dcl   p                   ptr;
   i = howmuch;
   p = where;
   data_width = 0;                        /* Bytes read      20090922*/
   do while( i>0 );
     n = pSBB->SBB_lnsize - pSBB->SBB_col;/* Data left in buffer     */
     if i<n then n=i;                     /* n=min(i,n)              */
     if pª=SYSNULL then do;               /* Move data               */
       call plimove(p,pSBB->SBB_pline,n);
       data_width = data_width+n;         /* Count bytes read        */
       end;
     i = i-n;                             /* Adjust addr and count   */
     p = p+n;
     pSBB->SBB_pline  = pSBB->SBB_pline+n;/* Bump line ptr           */
     pSBB->SBB_col    = pSBB->SBB_col+n;  /* Bump col position       */
     if pSBB->SBB_col = pSBB->SBB_lnsize &/* End of line?            */
        i>0                               /*  and more data needed?  */
     then do; 
       call PL.SPL_LineEnd(0,0);          /*  yes, get next line     */
       end;
     /* COMMENT: If ENDFILE occurs, the read returns here.           */
     /*          Partial data may have been read, just recognize     */
     /*          this now and exit.                                  */
     if pSBB->SBB_pline = SYSNULL() then i=0;
     end; /* do while */
   end move_from_buffer;

 %page;
 /*------------------------------------------------------------------*/
 /*                     GET DATA                                     */
 /*------------------------------------------------------------------*/
 Data: proc;
/* GET DATA not yet implemented for 0.9.10*/
/* NOTE: Need to pass info needed for iSubs, maybe pass SRB address? */
   call GetD(pData,pDesc,pName);                                       
   end Data;

 %page;
 /*------------------------------------------------------------------*/
 /* Multics: "When a pagemark occurs in the input stream, it is      */
 /*           treated as a data character;  thus an input stream     */
 /*           is treated as a single page divided into any number    */
 /*           of lines."      - AM83.0, p. 14-3                      */
 /*           (place this comment appropriately)                     */
 /*------------------------------------------------------------------*/
 /*------------------------------------------------------------------*/
 /*                     GET EDIT                                     */
 /*                                                                  */
 /* To do: * C-Format                                                */
 /*        * E-Format                                                */
 /*        * P-Format: character and float pictures                  */
 /*                                                                  */
 /*------------------------------------------------------------------*/
 Edit: proc;
 dcl     pFmtItem            ptr;
 dcl     Desc                bit(32)   based;
 dcl     pPic                ptr;      /* For P-format items         */
 dcl     moved_width         fixed bin(31);
 dcl     target_width        fixed bin(31);

 /*-------------------------*/
 /* 'Fmt' Parameter List    */
 /*-------------------------*/
 dcl   1 FmtParm,
         5 fp_ppFmt          ptr,           /* -> addr( Format_addr )*/
         5 fp_paFmt          ptr,           /* -> addr( Format_chain)*/
         /* Note double-indirection.  These are the address of the   */
         /*      address of the current format item, and the         */
         /*      address of the address of the R format chain.       */
         5 fp_pDSA           ptr,           /* -> addr( Current_DSA )*/
         5 fp_fmtid          fixed bin(7),  /* Base format id        */
         5 fp_nond           fixed bin(7),  /* 1=non-data item       */
         5 fp_np_real        fixed bin(7),  /* Real parameter count  */
         5 fp_np_imag        fixed bin(7),  /* Imag parameter count  */
         5 fp_fmtid_real     fixed bin(7),  /* Real part of C format */
         5 fp_fmtid_imag     fixed bin(7),  /* Imag part of C format */
         /* The significance of the operands varies by format id,    */
         /* they represent widths, positions, scale factors, etc.    */
         5 fp_opnd_real   (4)fixed bin(31), /* Variable dep. on fmt  */
         5 fp_opnd_imag   (4)fixed bin(31), /* Variable dep. on fmt  */
         5 fp_end            char(0);       /* End of FmtParm block  */
 %page;

   /*-------------------------------------------*/
   /* Set up workarea for format processor.     */
   /*-------------------------------------------*/
   fp_ppFmt = addr( pSRB->SRB_pFmt );  /* **Double-Indirect**        */
   fp_paFmt = addr( pSRB->SRB_aFmt );  /* **Double-Indirect**   0.9.1*/
   fp_pDSA  = pSRB->SRB_pDSA;

   /* NOTE: GET/PUT of a structure or array: each element receives a */
   /*       separate format item.                                    */

   /*----------------------------------------------------------------*/
   /* For GET/PUT of a structure or array, each element receives a   */
   /* separate format item.                                          */
   /*----------------------------------------------------------------*/
   if pDesc->AR_id = '30'x |           /* Array?                     */
      pDesc->AR_id = '31'x
   then call edit_array;               /* Yes                        */
   else if pDesc->SD_id = '80'x        /* Structure?                 */
        then call edit_struct;         /* Yes                        */
        else call edit_element(pData,pDesc); /* Otherwise elemen1.0.0*/
   return;

 /*---------------------------------------------*/
 /* GET EDIT Structure                          */
 /*---------------------------------------------*/
 edit_struct: proc;
   /* AggIO will process the structure and call edit_element once    */
   /* for each structure element                                     */
   pName = sysnull();
   call AggIO(pDesc,pData,pName,edit_element,sysnull,sysnull);/*1.2.1*/
   end edit_struct;

 /*---------------------------------------------*/
 /* GET EDIT Array                              */
 /*---------------------------------------------*/
 edit_array: proc;   
   /* AggIO will process the array and call edit_element once for    */
   /* each array element                                             */
   pName = sysnull();
   call AggIO(pDesc,pData,pName,edit_element,                 /*1.2.1*/
              pSRB->SRB_P1, pSRB->SRB_P2 );                   /*1.3.1*/
   end edit_array;

 /*---------------------------------------------*/
 /* GET EDIT Element                            */
 /*---------------------------------------------*/
 edit_element: proc(pData,pDesc);                             /*1.0.0*/
   dcl   (pData,pDesc)        ptr;                            /*1.0.0*/
   dcl    pPic                ptr;                          /*0.9.10b*/
   dcl    bErr                bit(1)              init( '0'b );/*.0.0*/

   /*-------------------------------------------*/
   /* Find the matching format-spec for this    */
   /* data element.                             */
   /*-------------------------------------------*/
   pFmtItem = fp_ppFmt->pVoid;         /* Stopper for format loop    */

   call Format( addr(FmtParm) );       /* Retrieve next format item  */
   do while( fp_nond=1 );              /* Process non-data items     */
     /* Process the format-spec.  This may be COLUMN, LINE, PAGE, X, */
     /* or SKIP.  R is processed within 'Format' and not seen here.  */
     select( fp_fmtid );
       /* Field-width required for these items */
       when( 3) call PL.SPL_LineEnd( 1, fp_opnd_real(1) );/* COL(n)  */
       when( 7) call PL.SPL_LineEnd( 2, fp_opnd_real(1) );/* LINE(n) */
       when( 9) call PL.SPL_LineEnd( 3, 0 );              /* PAGE    */
       when(11) call PL.SPL_LineEnd( 4, fp_opnd_real(1) );/* SKIP(n) */
       when(12) call x( fp_opnd_real(1) );                /* X(n)    */
       end; /* select */
     call Format( addr(FmtParm) );     /* Retrieve next format item  */

     error_code = '1';                                       /*0.9.10*/
     if pFmtItem = fp_ppFmt            /* If this occurs the entire  */
     then goto signal_error;           /* FORMAT has been processed  */
                                       /* with no data format-items. */
     end; /* do while */

   error_code = '2';                                         /*0.9.10*/
   if pDesc->ST_id = '50'x             /* Program-control data       */
   then goto signal_error;             /* Is this what we want to do?*/

   /* After ruling out program control, here are the types of data   */
   /* which can be processed:                                        */
   /*     . Coded arithmetic (base, scale, and mode)                 */
   /*     . Character                                                */
   /*     . Bit                                                      */
   /*     . Picture                                                  */

   field_width = fp_opnd_real(1);           /* Get format field width*/
   if fp_fmtid = 8 then do;                 /* 'P' format     0.9.10b*/
     pPic = ptrvalue(fp_opnd_real(1));      /* ->format       0.9.10b*/
     field_width = pPic->NP_size;                           /*0.9.10b*/
     end;                                                   /*0.9.10b*/
   /* COMMENT: Default behavior for GET EDIT(...)(a) with no length  */
   /*          specified is to return the null string.               */
   /*          The Enterprise PL/I manual, however, reads thusly:    */
   /*            "If an A-format item is specified without a length  */
   /*             in a GET EDIT statement, the compiler issues a     */
   /*             warning message and treats it as an L-format item".*/
   /*                                  -SC27-1460-04, p.303          */
   if fp_np_real=0 & fp_fmtid=0                               /*0.9.9*/
   then fp_fmtid = 15;                                        /*0.9.9*/

   /* For L format-item, the field width is the remainder of the line*/
   /* if this is the first line, we need to read first.              */
   if fp_fmtid=15 then do;                  /* L Format-item    0.9.3*/
     field_width = pSBB->SBB_lnsize - pSBB->SBB_col;          /*0.9.3*/
     /* If at end of current line read a new line and use that  0.9.3*/
     if pSBB->SBB_col >= pSBB->SBB_lnsize                     /*0.9.5*/
     then do;                                                 /*0.9.3*/
       call PL.SPL_LineEnd(0,0);            /*  Get next line   0.9.3*/
       field_width = pSBB->SBB_lnsize;                        /*0.9.3*/
       end;                                                   /*0.9.3*/
     end; /* L-format */                                      /*0.9.3*/

   /******************************************************************/
   /* BEGIN-block allows 'big_buffer' to be allocated on the stack   */
   /* rather then as a CONTROLLED variable or via the ALLOCATE       */
   /* builtin.  This means that it need not be freed if an error     */
   /* occurs converting the input data.                              */
   /******************************************************************/
   begin;
     dcl big_buffer          char(field_width);
     dcl DescAddr            ptr;      /* ->Intermediate descriptor  */
     dcl DataAddr            ptr;      /* ->Intermediate data        */
     dcl InterDesc           char(8);  /* Intermediate data descr.   */
     dcl CharDesc            char(8);  /* Character data descriptor  */

     /*--------------------------------------------------------------*/
     /* Read data into temporary buffer and build descriptor.        */
     /*--------------------------------------------------------------*/
     moved_width=0;                                           /*0.9.9*/
     data_width =0;                                           /*0.9.9*/
     if field_width>0                                         /*0.9.9*/
     then call move_from_buffer( addr(big_buffer), field_width );
     /* COMMENT: In case of EOF, a short string may have been read;  */
     /*          the actual length read is in 'data width'.          */
     /* The only case in which a zero length should be returned      */
     /* is when there is no more data on the line for L-format       */
     /* Otherwise ENDFILE should be raised.                          */
     if data_width=0 & fp_fmtid^=15 then do;                  /*0.9.9*/
       call PL.SPL_LineEnd(0,0);        /* Raise ENDFILE or ERROR.9.9*/
       return;                                                /*0.9.9*/
       end;                                                   /*0.9.9*/
     /* Following deleted 2015-07-23                                 */
     /*if data_width=0 then return;     /* ENDFILE occured   20090922*/
     moved_width = min(data_width,field_width);
     call PLIFILL( addr(CharDesc), '00'x, stg(CharDesc) );
     addr(CharDesc)->pli_ded_STR.ST_id  = '10'x;
     addr(CharDesc)->pli_ded_STR.ST_len = data_width;
     call PLIFILL( addr(InterDesc), '00'x, stg(InterDesc) );
     DescAddr = addr(InterDesc);

     /*--------------------------------------------------------------*/
     /* Convert data to match Format-Spec.                           */
     /*--------------------------------------------------------------*/
     select( fp_fmtid );

       /*-------------------*/
       /* 'A' Format Item   */
       /*-------------------*/
       when( 0) do;                    /* A Format item              */
         DataAddr = addr(big_buffer);
         DescAddr->pli_ded_STR.ST_id  = '10'x;
         DescAddr->pli_ded_STR.ST_len = field_width;
         /* No conversion, data is already CHARACTER                 */
         end; /* A */

       /*-------------------*/
       /* 'B' Format Item   */
       /*-------------------*/
       when( 1) do;                        /* B Format item          */
         DataAddr = addr(big_buffer);
         DescAddr->pli_ded_STR.ST_id  = '20'x;
         DescAddr->pli_ded_STR.ST_len = data_width;
         /* Convert CHARACTER to BIT */
         call encode_bits(addr(CharDesc),DescAddr,DataAddr, /*0.9.10b*/
                          data_width );                     /*0.9.10b*/
         end; /* B */

       /*-------------------*/
       /* 'C' Format Item   */
       /*-------------------*/
       when( 2) goto signal_unimplemented; /* C Format item          */

       /*-------------------*/
       /* 'E' Format Item   */
       /*-------------------*/
       when( 4) goto signal_unimplemented; /* E Format item          */
 
       /*-------------------*/
       /* 'F' Format Item   */
       /*-------------------*/
       when( 5) do;                        /* F Format item          */
         DescAddr->pli_ded_XD.XD_id    = '42'x;
         DescAddr->pli_ded_XD.XD_scale = fp_opnd_real(2);
         DescAddr->pli_ded_XD.XD_prec  = 18; /* 'max_prec_fixdec'    */
         if big_buffer = '' then do;
           addr(num_workarea)->FD18 = 0;
           end;
         else do;
           call CCA( addr(big_buffer),     /* ->Source string        */
                     addr(CharDesc),       /* ->Source descriptor    */
                     addr(num_workarea),   /* ->Target data          */
                     DescAddr,             /* ->Target descriptor    */
                     SYSNULL() );          /* Onfile                 */
           /* NOTE: ONFILE needs to be passed in SRB                 */
           end;
         /* IBM: "If the entire field is blank, it is interpreted    */
         /*       as zero.  (This is different from CHAR to ARITH    */
         /*       conversion and from E format-items."               */
         /*                          - SC26-3114-01, p.279.          */
         DataAddr = addr(num_workarea);    /* ->Intermediate data    */
         end; /* F */

       /*-------------------*/
       /* 'G' Format Item   */
       /*-------------------*/
       when( 6) goto signal_unimplemented; /* G Format not impl.     */

       /*-------------------*/
       /* 'P' Format Item   */
       /*-------------------*/
       when( 8) do;                        /* P Format item          */
         DescAddr = pPic;                  /* ->Picture Desc  0.9.10b*/
         if pPic->NP_id^='45'x then do;    /* TEMP: Not float 0.9.10b*/
           goto signal_unimplemented;                         /*1.0.0*/
           return;
           end;
         DataAddr = addr(big_buffer);                         /*0.9.3*/
         addr(num_workarea)->FD18 = 0;                      /*0.9.10b*/
         num_workarea(1) =  NPI( DataAddr, DescAddr );      /*0.9.10b*/
         DataAddr = addr(num_workarea);    /* Only for num pic0.9.10b*/
         call PLIFILL( addr(InterDesc), '00'x, stg(InterDesc) );
         addr(InterDesc)->XD_id  = '42'x;  /* FIXED DEC       0.9.10b*/
         addr(interDesc)->XD_scale = pPic->NP_scale;        /*0.9.10b*/
         addr(interDesc)->XD_prec  = pPic->NP_prec;         /*0.9.10b*/
         DescAddr = addr(InterDesc);
         end; /* P */

       /*-------------------*/
       /* 'B4' Format Item  */
       /*-------------------*/
       when(13) do;                                           /*1.0.0*/
         /* Convert HEX CHARACTER to BIT string */            /*1.0.0*/
         call get_hex(addr(big_buffer),addr(big_buffer),      /*1.0.0*/
                      data_width,field_width,                 /*1.0.0*/
                      pDesc );                                /*1.0.0*/
         call plifill(DescAddr,'00'x,stg(pli_ded_STR));       /*1.0.0*/
         DescAddr->pli_ded_STR.ST_id    = '20'x;              /*1.0.0*/
         DescAddr->pli_ded_STR.ST_len = field_width*4;        /*1.0.0*/
         DataAddr = addr(big_buffer);                         /*1.0.0*/
         end; /* B4 */                                        /*1.0.0*/

       /*-------------------*/
       /* 'B3' Format Item  */
       /*-------------------*/
       when(14) do;                                           /*1.0.0*/
         /* Convert OCTAL CHARACTER to BIT string */
         call get_oct(addr(big_buffer),addr(big_buffer),
                      data_width,field_width,                 /*1.0.0*/
                      pDesc );                                /*1.0.0*/
         DataAddr = addr(big_buffer);
         DescAddr->pli_ded_STR.ST_id  = '20'x;
         DescAddr->pli_ded_STR.ST_len = field_width*3;
         DataAddr = addr(big_buffer);                         /*1.0.0*/
         end; /* B3 */                                        /*1.0.0*/

       /*-------------------*/
       /* 'L' Format Item   */
       /*-------------------*/
       when(15) do;                        /* L Format item     0.9.3*/
         DataAddr = addr(big_buffer);                         /*0.9.3*/
         DescAddr->pli_ded_STR.ST_id  = '10'x;                /*0.9.3*/
         DescAddr->pli_ded_STR.ST_len = moved_width;          /*0.9.3*/	 	               
	 end; /* L */                                         /*0.9.3*/

       end; /* select */
  
     if bErr then do;                    /* Data error                 */
       error_code = '6';                                       /*0.9.10*/
/*     if isStr(pD) then goto signal_error;*/
       /* Otherwise the input was a numeric value                      */
       /* NOTE: This is incomplete.  CONVERSION needs to provide       */
       /*        information for the ONCHAR, ONFILE, and ONSOURCE bifs.*/
       num_workarea = 0;
       /* Before raising CONVERSION, set the result field to zero,     */
       /* so that an abnormal return from the ON-unit can proceed.     */
/*     call move_result( pDesc, pData, pD, pX );   */
       signal CONVERSION;
       return;
       end; /* bErr */

     /*--------------------------------------------------------------*/
     /* Data is now in specified format, next move converted data    */
     /* to target field; additional conversion may be required.      */
     /* Much to my surprise, I find that the input format doesn't    */
     /* have to agree with the target field.  E.G., it is possible   */
     /* to read a FIXED DEC(5) field with a B(1) format.             */
     /*--------------------------------------------------------------*/
     call move_result( pDesc,    pData,
                     DescAddr, DataAddr );
		     
     end; /* BEGIN-block */            /* 'big_buffer' is freed      */

   /*-----------------------*/
   /* Update COUNT          */
   /*-----------------------*/
   PL.SPL_Count = PL.SPL_Count+1;

   end edit_element;                                         /*0.9.10*/

   end Edit;

 %page;
 /*------------------------------------------------------------------*/
 /*                     GET List                                 0.7c*/
 /*------------------------------------------------------------------*/
 List: proc;
   if pDesc->AR_id = '30'x |           /* Array?                     */
      pDesc->AR_id = '31'x
   then call list_array;                                     /*0.9.10*/
   else if pDesc->SD_id = '80'x        /* Structure?                 */
   then call list_struct;                                    /*0.9.10*/
   else call list_element(pData,pDesc,sysnull());            /*0.9.10*/

 /*----------------------------------*/
 /* GET LIST(structure)              */
 /*----------------------------------*/
 list_struct: proc;                                          /*0.9.10*/	   
   /* AggIO will process the structure and call list_elem once for   */
   /* each structure element                                         */
   call AggIO(pDesc,pData,sysnull(),list_element,sysnull,sysnull);     	           
   end list_struct;

 /*----------------------------------*/
 /* GET LIST(array)                  */
 /*----------------------------------*/
 list_array: proc;                                           /*0.9.10*/
   /* AggIO will process the array and call list_elem once for       */
   /* each array element                                             */
   call AggIO(pDesc,pData,sysnull(),list_element,             /*1.2.1*/	           
              pSRB->SRB_P1, pSRB->SRB_P2 );                   /*1.3.1*/
   end list_array;

 /*----------------------------------*/
 /* GET LIST(element)                */
 /*----------------------------------*/
 list_element: proc(pData,pDesc,pName);                      /*0.9.10*/
   dcl  (pData,pDesc,pName)  ptr;                            /*0.9.10*/
   dcl   pN                  ptr;      /* ->Name (and subscript info)*/
   dcl   StringData          bit(1)    init( '0'b );
   dcl   BitData             bit(1)    init( '0'b );
   dcl  (lbp,lbe)            ptr;
   dcl   c                   char(1);
   dcl   quote               char(1);
   dcl   state               fixed bin(7)        init(0);
   dcl   bStr                bit(1)              init( '0'b );
   dcl   bErr                bit(1)              init( '0'b );
   dcl   TooLong             bit(1)              init( '0'b );
   dcl  (pD,pX)              ptr;

   call plifill( addr(desc_workarea), '00'x, stg(desc_workarea) );
   num_workarea = 0;
   pD = addr(desc_workarea);
   field_width = 64;                   /* Default buffer size        */
   /* COMMENT: In the case of a string, the actual number of         */
   /*          characters to be read may be greater than the length  */
   /*          of the string.  For ''X hex character strings the     */
   /*          number is double the length.  For ''BX bit strings    */
   /*          the number is four times the length, and for ''B      */
   /*          bit strings eight times!                              */
   /*          This should be okay for numbers, since the number of  */
   /*          digits will normally be less than 64.  It will not be */
   /*          correct for some pathological cases of character      */
   /*          strings in the input being read into numbers if there */
   /*          are lots of leading blanks in the string.             */
   if isStr(pDesc) then do;                                  /*0.9.10*/
     bStr = '1'b;                      /* Indicate string            */
     field_width = pDesc->ST_len;      /* Get buffer size      0.9.10*/
     if pDesc->XB_id = '10'x | pDesc->XB_id = '11'x   /* Char  0.9.10*/
     then field_width = 2*field_width;
     else field_width = 8*field_width;
     end; /* string */

   /******************************************************************/
   /* BEGIN-block allows 'big_buffer' to be allocated on the stack   */
   /* rather then as a CONTROLLED variable of via the ALLOCATE       */
   /* builtin.  This means that it need not be freed if an error     */
   /* occurs converting the input data.                              */
   /******************************************************************/
   begin;
     dcl big_buffer          char(field_width);
     dcl big_buffer_desc     char(8);                         /*1.3.1*/
     big_buffer_desc = (8)'00'x;                              /*1.3.1*/
     addr(big_buffer_desc)->ST_id = '10'x;                    /*1.3.1*/
     addr(big_buffer_desc)->ST_len = field_width;             /*1.3.1*/
     lbp = addr(big_buffer);
     lbe = addr(big_buffer) + stg(big_buffer)-1;
     pD = addr(big_buffer_desc);                              /*1.3.1*/
     big_buffer_desc = (8)'00'x;                              /*1.3.1*/
     addr(big_buffer_desc)->ST_id = '10'x;   /* Nonvarying char 1.3.1*/

  scn: do while( '1'b );               /* Scan input stream          */
     dummy: do;
       c = '00'x;                      /* Pre-initialize input buffer*/
       call move_from_buffer(addr(c),1); /* Get next character       */
       /* COMMENT: In case of EOF, a short string may have been read;*/
       /*          the actual length read is in 'data width'.        */
       if data_width=0   then do;       /* EOF                 0.9.10*/
          data_width = lbp - addr(big_buffer);               /*0.9.10*/
/*        bErr = encode_num( addr(big_buffer), data_width );  /*1.3.1*/
          leave scn;                                          /*1.3.1*/
          end; /*EOF */                                      /*0.9.10*/

       select( state );
         when(0) do;                   /* [[Initial state]]          */
           if c=' ' | c=TAB then leave dummy;  /* Leading whtspc.9.10*/
           if c=',' then leave scn;    /* Leading comma terminates   */
           if c='"' | c="'" then do;   /* Leading quote              */
             quote = c;                /* Save value                 */
             state = 2;
             leave dummy;
             end; /* quote */
	   /* If this is GET LIST( string ) the first non-whitespace */
	   /* character must be a quote.                             */
           error_code = '4';                                  /*1.0.0*/
	   if isStr(pDesc) then goto signal_error;            /*1.0.0*/ 
           lbp->C1 = c;                /* Stash this character       */
           lbp = lbp+1;
           state = 1;
           end; /* 0 */
         when(1) do;                   /* [[non-string]]             */
           if c=' ' | c=',' | c=TAB    /* End of field         0.9.10*/
           then do;
             data_width = lbp - addr(big_buffer);
/*           bErr = encode_num( addr(big_buffer), data_width );      */
             leave scn;
             end;
           if lbp=lbe then TooLong='1'b; /* Too much data            */
           else do;
             lbp->C1 = c;              /* Stash this character       */
             lbp = lbp+1;
             end;
           end; /* 1 */
         when(2) do;                   /* "string"                   */
           if c=quote then do;         /* Possible ending quote?     */
             state = 3;                /* Check it out               */
             /* Build a character descriptor now, in case    20090921*/
             /* this quote is the last character in the file.20090921*/
             data_width = lbp - addr(big_buffer);          /*20090921*/
             pD->ST_id  = '10'x;       /* Character string   20090921*/
             pD->ST_len = data_width;                      /*20090921*/
             leave dummy;
             end;
           if lbp=lbe then TooLong='1'b; /* Too much data            */
           else do;
             lbp->C1 = c;              /* Stash this character       */
             lbp = lbp+1;
             end;
           end; /* 2 */
         when(3) do;                   /* [[prev char was quote]]    */
           if c=quote then do;         /* Second quote in sequence?  */
             if lbp=lbe then TooLong='1'b; /* Too much data          */
             else do;
               lbp->C1 = c;            /* Stash this character       */
               lbp = lbp+1;
               end;
             state = 2;                /* Reset state in string      */
             leave dummy;
             end; /* quote-quote */
           data_width = lbp - addr(big_buffer);
           /* Otherwise this is the character following the string   */
           /* 'X', 'B', 'BX', ' ', or ','                            */
           if c='x' | c='X' then do;
             bErr = encode_hex( 0, addr(big_buffer), data_width );   
             call move_from_buffer(addr(c),1); /* Get char after 'X' */
             leave scn;
             end; /* X */
           if c='b' | c='B' then do;   /* Some-type of bit string    */
             state=4;                  /* Need to check more.        */
             leave dummy;
             end; /* B */
           pD->ST_id  = '10'x;         /* Character string           */
           pD->ST_len = data_width;
           leave scn;                  /* Vanilla character string   */
           end; /* 3 */
         when(4) do;                   /* [[Tell ''B from ''BX]]     */
           data_width = lbp - addr(big_buffer);
           if c='x' | c='X' then do;
             bErr = encode_hex( 1, addr(big_buffer), data_width );   
             call move_from_buffer(addr(c),1); /* Get char after 'X' */
             leave scn;
             end;
/*         if c='3' then do;                                           
/*           bErr = encode_octal( 1, addr(big_buffer), data_width );   
/*           call move_from_buffer(addr(c),1); /* Get char after 'X' */
/*           leave scn;
/*           end; */
           bErr = encode_bit( addr(big_buffer), data_width );
           leave scn;
           end; /* 4 */
           
         end; /* select */

       end dummy;
     end scn; /* do while */

   /*----------------------------------------------------------------*/
   /* Ending state tells what happened:                              */
   /*   0: No data read.  If c is not a comma, EOF occurred.         */
   /*   1: End of non-string datum.  c='00'x, comma, or blank.       */
   /*      desc_workarea indicates base, scale, mode, and precision. */
   /*      If TooLong='1'b, buffer size was exceeded.                */
   /*   2: Should not occur.                                         */
   /*   3: End of string datum.  desc_workarea indicates character,  */
   /*      hex char, bit, or hex bit.  If TooLong='1'b, buffer size  */
   /*      exceeded.   c=character following string.                 */
   /*   If TooLong='1'b, data in buffer is truncated.                */
   /*   if bErr='1'b the data contained an error.                    */
   /*----------------------------------------------------------------*/

   data_width = lbp - addr(big_buffer);                    /*20090922*/
   if data_width=0 then return;        /* ENDFILE occurred   20090922*/
   addr(big_buffer_desc)->ST_len = data_width;                /*1.3.1*/

   if c=' ' then call set_file_pos;    /* Set correct file position  */

   /* No data was read.  If this is a null field, STRZ can't occur.  */
   /* IBM: "A null field specifies that the value of the associated  */
   /*       data list item remains unchanged." -SC26-3114-01, p.263  */
   /* 
   if state=0 then return;             /* No data item               */

   /* NOTE: This was deleted 2024-07-29 for 1.3.1                    */
   /*       'encode_num' can also be deleted when this is.           */             
goto nope;
   /* Convert character string to numeric */
   if (pD->ST_id='10'x | pD->ST_id='11'x) &
       ªisStr(pDesc) then do;                                /*0.9.10*/
     error_code = '3';                                       /*0.9.10*/
     if bErr then goto signal_error;   /* Error reading string       */
     bErr = encode_num( addr(big_buffer), data_width );
     pD  = addr(desc_workarea);
     pX  = addr(num_workarea);                                /*1.3.1*/
     end;
nope:;

   /* Move the data read to the result field, maybe with conversion  */
   call move_result( pDesc, pData,                            /*1.3.1*/
                     addr(big_buffer_desc), addr(big_buffer) );/*.3.1*/
   PL.SPL_Count = PL.SPL_Count+1;

   end; /* BEGIN-block */              /* 'big_buffer' is freed      */

   /*-----------------------*/
   /* Update COUNT          */
   /*-----------------------*/
   PL.SPL_Count = PL.SPL_Count+1;

 /*------------------------------------------------------------------*/
 /* Set the correct file position following data item.               */
 /* IBM: "If the items are separated by a comma, the first           */
 /*       character scanned when the next GET statement is           */
 /*       executed is the one immediately following the comma.       */
 /*       If the items are separated by blanks only, the first       */
 /*       item scanned is the next nonblank character unless the     */
 /*       end of the record is encountered, in which case the        */
 /*       file is positioned at the end of the record.               */
 /*       However, if the end of the record immediately follows      */
 /*       a nonblank character (other than a comma), and the         */
 /*       following record begins with blanks, the file is           */
 /*       positioned at the first nonblank character in the          */
 /*       following record.  If the record does not terminate        */
 /*       with a comma, the succeeding record is not read in         */
 /*       until the next GET statement."    -SC26-3114-01, p.263     */
 /*       (examples omitted)                                         */
 /*------------------------------------------------------------------*/
 set_file_pos: proc;
   /* FIXME: Currently a noop */
   end set_file_pos;

   end list_element;

   end List;

 %page;
 /*------------------------------------------------------------------*/
 /* Convert intermediate data to match target attributes and move.   */
 /*------------------------------------------------------------------*/
 move_result: proc( pDTgt, pxTgt, pDSrc, pSrc );              /*0.9.5*/
   dcl   pDTgt               ptr;      /* ->Target Descriptor        */
   dcl   pxTgt               ptr;      /* ->Target Data         0.9.5*/
   dcl   pDSrc               ptr;      /* ->Source Descriptor        */
   dcl   pSrc                ptr;      /* ->Source Data              */
   dcl   pTgt                ptr;                            /*0.9.5*/
   
   dcl  (sLen,tLen)          fixed bin(31);
   dcl   n                   fixed bin(31);
   dcl   DescWorkarea        char(8);  /* ->Temporary Descriptor     */
   dcl   FltWorkarea         float bin(64);
   dcl   BinWorkarea         fixed bin(31);
   dcl   DecWorkarea         fixed dec(18);

   pTgt = pxTgt;                     /* This may be altered here0.9.5*/

   /*----------------------------------------------------------------*/
   /* The following conversions cover the case where the user        */
   /* reads a numeric item using a B or A format item                */
   /*----------------------------------------------------------------*/
   /* Convert bit string to numeric */
   if (pDSrc->ST_id='20'x | pDSrc->ST_id='21'x) &
       ªisStr(pDTgt) then do;
     BinWorkarea = CBA( pSrc, pDSrc );
     call plifill( addr(DescWorkarea), '00'x, stg(DescWorkarea) );
     addr(DescWorkarea)->XD_id   = '41'x; /* FIXED BIN        0.9.10b*/
     addr(DescWorkarea)->XD_prec = 31;                       /*0.9.10*/
     pSrc  = addr(BinWorkarea);
     pDSrc = addr(DescWorkarea);
     end;

   /* Convert character string to numeric */                 /*0.9.10*/
   if (pDSrc->ST_id='10'x | pDSrc->ST_id='11'x) &
       ªisStr(pDTgt) then do;
     call plifill( addr(DescWorkarea), '00'x, stg(DescWorkarea) );
     addr(DescWorkarea)->XD_id   = '43'x;  /* FIXED DECIMAL          */
     addr(DescWorkarea)->XD_prec = 18;                       /*0.9.10*/
     call CCA( pSrc, pDSrc, addr(num_workarea),
               addr(DescWorkArea), sysnull() );              /*0.9.10*/
     pDSrc = addr(DescWorkarea);
     pSrc  = addr(num_workarea);
     end;                                                    /*0.9.10*/

   /* Convert numeric to character string */
   /* NOTE: Can this occur for GET?       */
   if (pDTgt->ST_id='10'x | PDTgt->ST_id='11'x) &         
       ªisStr(pDSrc) then do;
     /* NOTE: 'sysnull' in the following call is the file */
     call CAC( pSrc, pDSrc, addr(char_workarea) );
     call plifill( addr(DescWorkarea), '00'x, stg(DescWorkarea) );
     addr(DescWorkarea)->ST_id  = '11'x;
     addr(DescWorkarea)->ST_len = 24;
     if (pDSrc->XD_cplx&'80'bx)='80'bx
     then addr(DescWorkarea)->ST_len = 48;
     pSrc  = addr(char_workarea);
     pDSrc = addr(DescWorkarea);
     end;

   select( pDTgt->XB_id );             /* Target data type           */

     when( '10'x ) do;                 /* Nonvarying CHARACTER target*/
       tLen = pDTgt->pli_ded_STR.ST_len;
       if pDSrc->ST_id = '10'x then do;/* Nonvarying source          */
         sLen = pDSrc->pli_ded_STR.ST_len;
         end;
       else do;                        /* VARYING source             */
         sLen = length(pSrc->VarStr);
         pSrc = pSrc+stg(null()->VarStr);
         end;
      if sLen>tLen then do;
         /* raise STRINGSIZE if enabled */
         sLen = tLen;
	 if M_stringsize then signal STRINGSIZE;              /*0.9.5*/
         end; /* sLen>tLen */
       call PLIFILL( pTgt, ' ', tLen );                       /*0.9.5*/
       call PLIMOVE( pTgt, pSrc, sLen );
       end; /* nonvarying CHARACTER */

     when( '11'x ) do;                 /* VARYING CHARACTER target   */
       tLen = pDTgt->pli_ded_STR.ST_len;
       if pDSrc->ST_id = '10'x then do;/* Nonvarying source          */
         sLen = pDSrc->pli_ded_STR.ST_len;
         end;
       else do;                        /* VARYING source             */
         sLen = length(pSrc->VarStr);
         pSrc = pSrc+stg(null()->VarStr);
         end;
       if sLen>tLen then do;
         /* raise STRINGSIZE if enabled */
         sLen = tLen;
	 if M_stringsize then signal STRINGSIZE;              /*0.9.5*/
         end; /* sLen>tLen */
       pTgt->VarStrLen = sLen;
       pTgt = pTgt + stg(null()->VarStrLen);
       if sLen>0                                              /*0.9.9*/
       then call PLIMOVE( pTgt, pSrc, sLen );
       end; /* VARYING CHARACTER */

     when( '20'x ) do;                 /* Nonvarying BIT target      */
       /* Source is always nonvarying bit                            */
       tLen = pDTgt->pli_ded_STR.ST_len;
       sLen = pDSrc->pli_ded_STR.ST_len;
       n = pdTgt->ST_bo + 1;                                /*0.9.10b*/
       if sLen>tLen then do;
         /* raise STRINGSIZE if enabled */
         sLen = tLen;
	 if M_stringsize then signal STRINGSIZE;              /*0.9.5*/
         end; /* sLen>tLen */
       substr(pTgt->B8,n,TLen) = substr(pSrc->B8,1,SLen);   /*0.9.10b*/
       end; /* nonvarying BIT */

     when( '21'x ) do;                 /* VARYING BIT target         */
       /* Source is always nonvarying bit                            */
       tLen = pDTgt->pli_ded_STR.ST_len; /*Here the maximum length   */
       sLen = pDSrc->pli_ded_STR.ST_len;
       if sLen>tLen then do;
         /* raise STRINGSIZE if enabled */
         sLen = tLen;
	 if M_stringsize then signal STRINGSIZE;              /*0.9.5*/
         end; /* sLen>tLen */
       pTgt->VarStrLen = sLen;
       pTgt = pTgt + stg(null()->VarStrLen);
       /* COMMENT: These are always aaligned */
       if sLen>0                                            /*0.9.10b*/
       then substr(pTgt->B8,1,TLen) = substr(pSrc->B8,1,SLen);/*9.10b*/
       end; /* VARYING BIT */
 
     /*--------------------------------------------------------------*/
     /* Convert numeric input to target base, scale, mode, and prec. */
     /*--------------------------------------------------------------*/
     when( '41'x, '42'x, '43'x, '44'x, '48'x ) do; /* Num target0.9.6*/
       call Cnvt( pSrc, pDSrc, pTgt, pDTgt );                  /*0.7c*/
       end; /* numeric */                                      /*0.7c*/

     /*--------------------------------------------------------0.9.10*/
     /* Pictured data converted to char/num on input           0.9.10*/
     /*--------------------------------------------------------0.9.10*/

     /* 'OTHERWISE' means that the target is program-control data.   */
     otherwise do;                                           /*0.9.10*/
     /*display( heximage(pDTgt,8) ); /**/
       error_code = '5';                                     /*0.9.10*/
       goto signal_error;
       end;                                                  /*0.9.10*/

     end; /* select */

   end move_result;
 %page;

 /*------------------------------------------------------------------*/
 /* Encode a Hex character (type=0) or bit (type=1) string.          */
 /*------------------------------------------------------------------*/
 encode_hex: proc(type,pData,lData) returns( bit(1) );
   dcl   type                fixed bin(7);
   dcl   pData               ptr;
   dcl   lData               fixed bin(31);
   dcl  (p,q)                ptr;
   dcl   i                   fixed bin(7);
   dcl   j                   fixed bin(31);
   dcl   x                   fixed bin(31);
   dcl   bErr                bit(1)              init( '0'b );
   p = addr(desc_workarea);            /* Build output descriptor    */
   if type=0                           /* Hex character string       */
   then do;
     p->ST_id  = '10'x;
     p->ST_len = lData/2;
     end;
   else do;                            /* Hex bit string             */
     p->ST_id  = '20'x; 
     p->ST_len = lData*4;
     end;
   p,q = pData;
   do j=1 to lData;
     i = index(pData->C1,HexChar);
     if i>16 then i=i-6;
     if i>0 then i=i-1;
     else bErr='1'b;
     x=i*16;
     j=j+1;
     p=p+1;
     if j<=lData then do;
       i = index(pData->C1,HexChar);
       if i>16 then i=i-6;
       if i>0 then i=i-1;
       x=x+i;
       p=p+1;
       end;
     q->C1 = byte(x);
     q = q+1;
     end; /* do i */
   lData = q-pData;
   return( bErr );
   end encode_hex;

 /*------------------------------------------------------------------*/
 /* Encode a Bit string                                              */
 /*------------------------------------------------------------------*/
 encode_bit: proc(pData,lData) returns( bit(1) );
   dcl   pData               ptr;
   dcl   lData               fixed bin(31);
   dcl  (p,q)                ptr;
   dcl   i                   fixed bin(7);
   dcl  (j,k)                fixed bin(31);
   dcl   b8                  bit(8);
   dcl   bErr                bit(1)              init( '0'b );
   p = addr(desc_workarea);            /* Build output descriptor    */
   p->ST_id  = '20'x; 
   p->ST_len = lData;   
   p,q = pData;
   do j=1 to lData by 8;
     b8 = '0'bx;
     do k=1 to 8;
       if p->C1='1' then substr(b8,k,1)='1'b;
       else if p->C1ª='0' then bErr='1'b;
       p=p+1;
       if j+k>lData then leave;
       end; /* do k */
     q->C1 = byte(b8);
     q = q+1;
     end; /* do i */
   lData = q-pData;
   return( bErr );
   end encode_bit;

 /*------------------------------------------------------------------*/
 /* Encode a Numeric input string                                    */
 /*------------------------------------------------------------------*/
 encode_num: proc(pData,lData) returns( bit(1) );
   dcl   pData               ptr;
   dcl   lData               fixed bin(31);
   dcl   pDesc               ptr;
   call plifill( addr(desc_workarea), '00'x, stg(desc_workarea) );
   pDesc = addr(desc_workarea);
   pDesc->ST_id  = '10'x;              /* Nonvarying character       */
   pDesc->ST_len = lData;
   call NumVal( pData, pDesc, 
                addr(char_workarea), addr(desc_workarea) 
              );
   if addr(desc_workarea)->XB_id='00'x /* Error                      */
   then return( '1'b );
   end encode_num;

 /*-----------------------------------------------------------0.9.10b*/
 /* Encode a Character string as bits                         0.9.10b*/
 /*-----------------------------------------------------------0.9.10b*/
 encode_bits: proc(pCDesc,pBDesc,pData,lData);              /*0.9.10b*/
   dcl  (pCDesc,pBDesc)      ptr;
   dcl   pData               ptr;
   dcl   lData               fixed bin(31);
   dcl 1 Src_LD,
         5 SrcDat            ptr,
         5 SrcDesc           ptr;
   dcl 1 Dst_LD,
         5 DstDat            ptr,
         5 DstDesc           ptr;
   dcl   BitBucket           char((lData+7)/8);
   
   SrcDat  = pData;                     /* Set up locator/desc       */
   SrcDesc = pCDesc;
   DstDat  = addr(bitBucket);
   DstDesc = pBDesc;
   /* NOTE: Last argument is ONFILE */
   call CCB( addr(Src_LD), addr(Dst_LD), sysnull() );
   call plifill( pData, '00'x, lData );
   call plimove( pData, addr(BitBucket), (lData+7)/8 );
   end encode_bits;                                         /*0.9.10b*/

 /*-------------------------------------------------------------1.0.0*/
 /* Encode a Hex character string                               1.0.0*/
 /* NOTE: Sadly, for HEX and Octal, shifting and oring is much       */
 /*       more efficient than bit substr or arrays.                  */
 /*-------------------------------------------------------------1.0.0*/
 get_hex: proc(pIn,pOut,data_width,field_width, pDesc);       /*1.0.0*/
   dcl   (pIn,pOut)          ptr;
   dcl   (data_width,field_width)
                             fixed bin(31);
   dcl    pDesc              ptr;       /* ->Source loc/desc    1.0.0*/

   dcl   (pI,pO)             ptr;
   dcl    lData              fixed bin(31);
   dcl    nibble             fixed bin(7);
   dcl    d                  fixed bin(7);
   dcl    i                  fixed bin(31);
   dcl    c                  char(1);
   dcl    bOut               fixed bin(7)    based(pO);   
   dcl    temp               fixed bin(7)    unsigned;
   dcl    state              fixed bin(7);
   dcl    result             char(field_width);

   lData = min(data_width,field_width);
   /*---------------------------------*/
   /* Loop to trap CONVERSION         */
   /* Calling program is responsible  */
   /* for handling condition          */
   /*---------------------------------*/
outer: do forever;
   pI = pIn;
   pO = addr(result);
   call plifill(addr(result),'00'x,stg(result));
   state  = 0;         
   nibble = 0;
convloop: do;                           /* Until no conversion       */
     do i=1 to field_width;   
       c = pI->C1;
       if c=' ' then do;                /* Got tired of nesting loops*/
         if state=0 then goto blank;    /* Leading blank             */
         state = 2;                     /* Trailing blank            */
         goto blank;
         end;
       if state=2 then goto signal_error;/* Data follows trail blank */
       state = 1;                        /* First non-blank          */
       d = index(hexchar,c);
       if d>16 then d=d-6;               /* Upper/lower case         */
       if d=0 then do;
         conv_onchar = pI;
         call signal_CONV( addr(conv_parms) );/* Signal CONVERSION   */
         leave convloop;                     /*  Retry conversion    */
         end;
       d = d-1;
       if nibble=0 then do;
         temp = ISLL(d,4);
         nibble=1;
         end;
       else do;
         temp = IOR(temp,d);
         bOut = temp;
         pO = pO+1;
         nibble=0;
         end;
     blank: ;                           /* Come here for leading blk */
       pI = pI+1;
       end; /* do i */
     end; /* convloop */                                   /*1.0.0*/
   if nibble=1 then bOut=temp;
   call plimove(pOut,addr(result),field_width);
   return;
   end; /* outer */
   end get_hex;                                             /*0.9.10b*/

 /*-------------------------------------------------------------1.0.0*/
 /* Encode an Octal character string                            1.0.0*/
 /*-------------------------------------------------------------1.0.0*/
 get_oct: proc(pIn,pOut,data_width,field_width,pDesc);        /*1.0.0*/  
   dcl   (pIn,pOut)          ptr;
   dcl   (data_width,field_width)
                             fixed bin(31);
   dcl    pDesc              ptr;       /* ->Source loc/desc         */

   dcl   (pI,pO)             ptr;
   dcl    lData              fixed bin(31);
   dcl    nibble             fixed bin(7);
   dcl    d                  fixed bin(7)    unsigned;
   dcl    i                  fixed bin(31);
   dcl    c                  char(1);
   dcl    bOut               bit(24)         based(pO);
   dcl    temp               fixed bin(32)   unsigned;
   dcl    b32                bit(32);
   dcl    state              fixed bin(7);
   dcl    result             char(field_width);

   lData = min(data_width,field_width);
   /*---------------------------------*/
   /* Loop to trap CONVERSION         */
   /* Calling program is responsible  */
   /* for handling condition          */
   /*---------------------------------*/
outer: do forever;
   pI = pIn;
   pO = addr(result);
   call plifill(addr(result),'00'x,stg(result));
   state = 0;         
convloop: do;                           /* Until no conversion       */
     nibble = 1;
     temp=0;
     do i=1 to field_width;   
       c = pI->C1;
       if c=' ' then do;                /* Got tired of nesting loops*/
         if state=0 then goto blank;    /* Leading blank             */
         state = 2;                     /* Trailing blank            */
         goto blank;
         end;
       if state=2 then goto signal_error;/* Data follows trail blank */
       state = 1;                        /* First non-blank          */
       d = index(octchar,c);
       if d=0 then do;
         conv_onchar = pI;
         call signal_CONV( addr(conv_parms) );/* Signal CONVERSION   */
         leave convloop; /* <==   */         /*  Retry conversion    */
         end;
       d = d-1;
       temp = iSLL(temp,3);
       temp = IOR(temp,d);
       nibble = nibble+1;
       if nibble=9 then do;
         temp = ISLL(temp,8);
         b32 = temp;
         substr(bOut,1,24) = b32;
         nibble = 1;
         pO = pO+3;
         end; /* do i */                                      /*1.0.0*/
     blank: ;                           /* Come here for leading blk */
       pI = pI+1;
       end; /* do i */
     end; /* convloop */                                   /*1.0.0*/
   if nibble>1 then do;
     temp = ISLL(temp,32-((nibble-1)*3));
     b32 = temp;
     substr(bOut,1,nibble*3-3) = b32;
     end; /* nibble */
   call plimove(pOut,addr(result),field_width);
   return;
   end; /* outer */
   end get_oct;                                             /*0.9.10b*/

 /*------------------------------------------------------------------*/
 /* isStr: Return '1'b if descriptor identifies a string.            */
 /*------------------------------------------------------------------*/
 isStr: proc(p) returns( bit(1) );
   dcl   p                   ptr;
   if p->ST_id = '10'x | p->ST_id = '11'x |
      p->ST_id = '20'x | p->ST_id = '21'x
   then return( '1'b );
   return( '0'b );
   end isStr;

 /*------------------------------------------------------------------*/
 /* B2D: Convert number of binary to number of decimal digits        */
 /*------------------------------------------------------------------*/
 B2D: proc(n) returns( fixed bin(7) );
   dcl   n                   fixed bin(7);
   dcl   w                   fixed bin(7);
   dcl   i                   fixed bin(7);
   dcl   neg                 bit(1)              init( '0'b );
   if n=0 then return(0);
   w = n;
   if w<0 then do;
     neg='1'b;
     w = -w;
     end;
   do i=1 to 33;
     if w<n_3dot32(i) then leave;
     end;
   if neg then i=-i;
   return(i);
   end B2D;
 /*------------------------------------------------------------------*/
 /* Table lookup - CEIL(n*3.32) table Decimal to Binary digits       */
 /* NOTE: Same as code in 'EXPRES' and 'CONST'                       */
 /*------------------------------------------------------------------*/
 D2B: proc(n) returns( fixed bin(15) );
   dcl   n                   fixed bin(7);
   dcl   w                   fixed bin(7);
   dcl   i                   fixed bin(7);
   dcl   neg                 bit(1)              init( '0'b );
   if n=0 then return(0);
   w = n;
   if w<0 then do;
     neg='1'b;
     w = -w;
     end;
   if w<1 | w>hbound(n_3dot32,1) then return(0);
   i = n_3dot32(w);
   if neg then i=-i;
   return(i);
   end D2B;

 %page;

 signal_CONV: proc(p);
   dcl    p                   ptr;
   if M_Conversion then do;
     /*--------------------------------------------------------------*/
     /* "Signal CONVERSION;"                                         */
     /* This can't be done via SIGNAL statement due to the need to   */
     /* pass a parameter for the ONSOURCE and ONCHAR information.    */
     /*--------------------------------------------------------------*/
 (conversion):    
     call CONV( oncode_conv, p ); 
     /* Then return to caller to retry conversion */
     /* COMMENT: "If the ONSOURCE or ONCHAR pseudovariable is used,  */
     /*          the program retries the conversion on return from   */
     /*          the ON-unit.  If the error is not corrected, the    */
     /*          program loops.  If these pseudovariables are not    */
     /*          used, the ERROR condition is raised."               */
     /*             -SC26-3114-2, p.313,                             */
     /*          SIG checks to see whether these pseudovariables     */
     /*          have been used, and raises ERROR if not.  If the    */
     /*          code returns here, they have been used.             */
     end; /* M_CONVERSION */
   else do;                            /* CONVERSION disabled        */
     /* COMMENT: "If the CONVERSION condition is raised and it is    */
     /*          disabled, the program is in error."                 */
     /*          (I.E. The behavior is undefined.)                   */
     /*               -SC26-3114-2, p.313.                           */
     /*          Our default action is to raise ERROR.               */
     signal ERROR;
     end;
   end signal_CONV;
 %page;

 %include SRB;
 %include LOCDESC;
 %include DESC;
 %include N3DOT32;
 %include ONCODE; 

 end pli_Getx;
